Every day... 
Butone day

See the examples above. If I place the point after the "to" in the word "But" and then run smart-comma, the point jumps to the beginning of the buffer.

The bug is caused by the presence of the ellipsis ("...") if I remove the ellipsis and replace it with a period, the error goes away.

The error message:

#+BEGIN_SRC emacs-lisp
Debugger entered--Lisp error: (args-out-of-range -1 -1)
  replace-match("," nil t nil 2)
  (let* ((old-punct (match-string 2)) (was-after-punct (>= old-point (point)))) (replace-match "" nil t nil 1) (replace-match (or (if (and was-after-punct (not (string= old-punct ""))) (progn (let ((potential-new-punct ...)) (find-if (function ...) *smart-punctuation-exceptions*)))) new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn (if was-after-punct (my/fix-space) (save-excursion (my/fix-space))))))
  (let ((old-point (point))) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" (point))) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" (match-string 0))) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" (match-string 1))) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" (match-string 2))) (let* ((old-punct (match-string 2)) (was-after-punct (>= old-point (point)))) (replace-match "" nil t nil 1) (replace-match (or (if (and was-after-punct (not (string= old-punct ""))) (progn (let (...) (find-if ... *smart-punctuation-exceptions*)))) new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn (if was-after-punct (my/fix-space) (save-excursion (my/fix-space)))))))
  (if not-so-smart (let ((old-point (point))) (funcall --cl-go-back-- "[^ 	]") (insert new-punct) (goto-char old-point) (forward-char (length new-punct))) (let ((old-point (point))) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" (point))) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" (match-string 0))) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" (match-string 1))) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" (match-string 2))) (let* ((old-punct (match-string 2)) (was-after-punct (>= old-point (point)))) (replace-match "" nil t nil 1) (replace-match (or (if (and was-after-punct (not ...)) (progn (let ... ...))) new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn (if was-after-punct (my/fix-space) (save-excursion (my/fix-space))))))))
  (let ((--cl-go-back-- (function (lambda (regexp) (re-search-backward regexp nil t) (condition-case nil (progn (forward-char ...)) (error nil)))))) (if not-so-smart (let ((old-point (point))) (funcall --cl-go-back-- "[^ 	]") (insert new-punct) (goto-char old-point) (forward-char (length new-punct))) (let ((old-point (point))) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" (point))) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" (match-string 0))) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" (match-string 1))) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" (match-string 2))) (let* ((old-punct (match-string 2)) (was-after-punct (>= old-point (point)))) (replace-match "" nil t nil 1) (replace-match (or (if (and was-after-punct ...) (progn ...)) new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn (if was-after-punct (my/fix-space) (save-excursion ...))))))))
  (save-restriction (if (and (eql major-mode (quote org-mode)) (org-at-heading-p)) (progn (funcall --cl-print-debug-info-- "at heading\n") (save-excursion (org-beginning-of-line) (let ((heading-text (fifth ...))) (funcall --cl-print-debug-info-- (format "text: %s\n" heading-text)) (if heading-text (progn (search-forward heading-text) (funcall --cl-print-debug-info-- ...) (narrow-to-region ... ...))))))) (let ((--cl-go-back-- (function (lambda (regexp) (re-search-backward regexp nil t) (condition-case nil (progn ...) (error nil)))))) (if not-so-smart (let ((old-point (point))) (funcall --cl-go-back-- "[^ 	]") (insert new-punct) (goto-char old-point) (forward-char (length new-punct))) (let ((old-point (point))) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" (point))) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" (match-string 0))) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" (match-string 1))) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" (match-string 2))) (let* ((old-punct (match-string 2)) (was-after-punct (>= old-point ...))) (replace-match "" nil t nil 1) (replace-match (or (if ... ...) new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn (if was-after-punct ... ...))))))))
  (let ((--cl-print-debug-info-- (function (lambda (s) (save-current-buffer (set-buffer debug-buffer) (insert s)))))) (save-restriction (if (and (eql major-mode (quote org-mode)) (org-at-heading-p)) (progn (funcall --cl-print-debug-info-- "at heading\n") (save-excursion (org-beginning-of-line) (let ((heading-text ...)) (funcall --cl-print-debug-info-- (format "text: %s\n" heading-text)) (if heading-text (progn ... ... ...)))))) (let ((--cl-go-back-- (function (lambda (regexp) (re-search-backward regexp nil t) (condition-case nil ... ...))))) (if not-so-smart (let ((old-point (point))) (funcall --cl-go-back-- "[^ 	]") (insert new-punct) (goto-char old-point) (forward-char (length new-punct))) (let ((old-point (point))) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" (point))) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" (match-string 0))) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" (match-string 1))) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" (match-string 2))) (let* ((old-punct ...) (was-after-punct ...)) (replace-match "" nil t nil 1) (replace-match (or ... new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn ...))))))))
  (let ((debug-buffer (generate-new-buffer (generate-new-buffer-name "smart-punctutation-debug")))) (let ((--cl-print-debug-info-- (function (lambda (s) (save-current-buffer (set-buffer debug-buffer) (insert s)))))) (save-restriction (if (and (eql major-mode (quote org-mode)) (org-at-heading-p)) (progn (funcall --cl-print-debug-info-- "at heading\n") (save-excursion (org-beginning-of-line) (let (...) (funcall --cl-print-debug-info-- ...) (if heading-text ...))))) (let ((--cl-go-back-- (function (lambda ... ... ...)))) (if not-so-smart (let ((old-point ...)) (funcall --cl-go-back-- "[^ 	]") (insert new-punct) (goto-char old-point) (forward-char (length new-punct))) (let ((old-point ...)) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" ...)) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" ...)) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" ...)) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" ...)) (let* (... ...) (replace-match "" nil t nil 1) (replace-match ... nil t nil 2) (if ... ...))))))))
  smart-punctuation(",")
  smart-comma()
  #<subr call-interactively>(smart-comma nil nil)
  ad-Advice-call-interactively(#<subr call-interactively> smart-comma nil nil)
  apply(ad-Advice-call-interactively #<subr call-interactively> (smart-comma nil nil))
  call-interactively(smart-comma nil nil)
  command-execute(smart-comma)

#+END_SRC
