#+TITLE: Jay Dixit's GNU Emacs setup
* About
  - System: Mac OSX Yosemite
  - Emacs version: 24.5.1
  - Use case: GNU Emacs specific settings.

* Handle Emacs UTF-8 input

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setenv "LANG" "en_US.UTF-8")
#+END_SRC

* Sticky windows

#+BEGIN_SRC emacs-lisp
(global-set-key [(control x) (?0)] 'delete-other-windows)
(global-set-key [(control x) (?9)] 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-0") 'delete-window)
(global-set-key  (kbd "s-1") 'delete-other-windows)
(global-set-key  (kbd "s-9") 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-2") 'split-window-vertically)
(global-set-key  (kbd "s-3") 'split-window-horizontally)
#+END_SRC

* Abbreviations (autocorrect)

Automatically load abbreviations table:
#+BEGIN_SRC emacs-lisp
(setq-default abbrev-mode t)
(read-abbrev-file "~/Dropbox/elisp/.abbrev_defs")
(read-abbrev-file "~/Dropbox/elisp/own-abbrevs.abbrev_defs")
(setq save-abbrevs t)
#+END_SRC

* UI/Appearance

Clean UI:
#+BEGIN_SRC emacs-lisp
(tooltip-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode 1)
#+END_SRC

Don't highlight lines:
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
          (lambda()
            (hl-line-mode -1)
            (global-hl-line-mode -1))
          't
          )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq prelude-whitespace nil)
#+END_SRC

Wrap text:
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode)
#+END_SRC

* Fullscreen settings

[[http://amitp.blogspot.ca/2008/05/emacs-full-screen-on-mac-os-x.html][(Source)]]

#+BEGIN_SRC emacs-lisp
(defvar maxframe-maximized-p nil "maxframe is in fullscreen mode")

(defun toggle-maxframe ()
  "Toggle maximized frame"
  (interactive)
  (setq maxframe-maximized-p (not maxframe-maximized-p))
  (cond (maxframe-maximized-p (maximize-frame))
        (t (restore-frame))))

(define-key global-map [(s-return)] 'toggle-maxframe)
;; make it easy to go fullscreen
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

;; and the keybinding 
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f11>") 'toggle-fullscreen))
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f13>") 'toggle-fullscreen))

  (global-set-key (kbd "<f13>") 'toggle-fullscreen)
#+END_SRC

* Directory settings

There is probably a lot of redundancy here, I don't understand this stuff too
well.

#+BEGIN_SRC emacs-lisp
(defun mydired-sort ()
  "Sort dired listings with directories first."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
    (set-buffer-modified-p nil)))

(defadvice dired-readin
  (after dired-after-updating-hook first () activate)
  "Sort dired listings with directories first before adding marks."
  (mydired-sort)
  (let ((dired-details-internal-overlay-list  ())) (dired-details-hide)))

(add-hook 'dired-load-hook
	  (lambda ()
(require 'dired-sort-menu)))


(defcustom dired-details-hidden-string ""
  "*This string will be shown in place of file details and symbolic links."
  :group 'dired-details
  :type 'string)

(defcustom dired-details-initially-hide t
  "*Hide dired details on entry to dired buffers."
  :group 'dired-details
  :type 'boolean)
#+END_SRC

 omit certain specific uninteresting file types from dired
#+BEGIN_SRC emacs-lisp

(require 'dired-x)
(setq-default dired-omit-files-p t) ; this is buffer-local variable


;; (setq dired-omit-files "^\\.[^.]\\|\\.pdf$\\|\\.tex$\\|\\.DS_Store\\|\\.doc$\\|\\.docx$\\|\\.xlsx$\\|\\.ini$\\|\\.fsLockFile$\\|Icon")

(setq dired-omit-files "^\\.[^.]\\|\\.pdf$\\|\\.tex$\\|\\.DS_Store$\\|\\.doc$\\|\\.docx$\\|\\.ini$\\|\\.rtf$\\|\\Icon$")

;; Enable toggling of uninteresting files.
(setq dired-omit-mode t)
(setq-default dired-omit-files-p t) ; this is buffer-local variable

(defun enable-dired-omit-mode () (dired-omit-mode 1))
(add-hook 'dired-mode-hook 'enable-dired-omit-mode)


;; Load Dired X when Dired is loaded.
(add-hook 'dired-load-hook '(lambda () (require 'dired-x)))

;; so that I can hide details on dired
(require 'dired-details+)
#+END_SRC

* Other functions

Manually remove the scrollbar if default setting fails when creating a new frame:

#+BEGIN_SRC emacs-lisp
(defun scrollbar-init ()
  (interactive)
  (scroll-bar-mode -1)
  )
#+END_SRC


Forgot what this does, I think it's in case Emacs crashes maybe to recover
autosaves?
#+BEGIN_SRC emacs-lisp
(defadvice recover-session (around disable-dired-omit-for-recover activate)
  (let ((dired-mode-hook dired-mode-hook))
    (remove-hook 'dired-mode-hook 'enable-dired-omit-mode)
    ad-do-it))
#+END_SRC

* Isolate Emacs kill ring from the OSX system pasteboard (clipboard).

Very important, I use this all the time.  These are custom functions to separate
the OSX clipboard from Emacs' kill ring, effectively giving me two separate
clipboards to work from. The below are the traditional OSX keybindings for
cut/copy/paste, and they will now work with the OSX clipboard. The yank and pop functions still work, and use the Emacs kill ring instead.



#+BEGIN_SRC emacs-lisp
(setq interprogram-cut-function nil)
(setq interprogram-paste-function nil)

(defun pasteboard-copy()
  "Copy region to OS X system pasteboard."
  (interactive)
  (shell-command-on-region
   (region-beginning) (region-end) "pbcopy"))

;;; old version; remove after testing new one (see below)
;; (defun pasteboard-paste()
;;   "Paste from OS X system pasteboard via `pbpaste' to point."
;;   (interactive)
;; (my/fix-space)
;;   (shell-command-on-region
;;    (point) (if mark-active (mark) (point)) "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'" nil t)
;; (my/fix-space)
;; ;; (when (looking-back "^[[:space:]]+") (just-one-space)) ; this didn't work
;; )

;;; new version; not thoroughly tested
(defun pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
        (end (if mark-active
                 (mark)
               (point))))
    (shell-command-on-region start end
                             "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
                             nil t)
    (my/fix-space)
    (save-excursion
      (goto-char start)
      (my/fix-space))))

(defun pasteboard-cut()
  "Cut region and put on OS X system pasteboard."
  (interactive)
  (pasteboard-copy)
  (delete-region (region-beginning) (region-end))
(my/fix-space)
)
#+END_SRC

* Keybindings

** Create custom keybinding prefix 

[[http://stackoverflow.com/questions/5682631/what-are-good-custom-keybindings-in-emacs/5682737#5682737][Source]]
#+BEGIN_QUOTE
I have an unconventional approach to this that I recommend highly. I have
redefined the C-l ('ell') key to be a prefix key, and I use that to prefix my
favorite commands. This key is very easy to type and it is bound to a function
('recenter) that isn't used that much. Well, I don't use 'recenter much, but
even if you did, it can be assigned to C-l C-l which is almost as easy to type,
and a small price to pay for the possibilities opened up by the
Ctrl-L-map. (Actually I prefer 'redraw-display to 'recenter, so I gave that the
place of honor.)
#+END_QUOTE

Use ⌘-m as prefix for my own custom keybindings:
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "s-m"))
(defvar s-m-map (make-keymap)
  "Keymap for local bindings and functions, prefixed by (Command-M)")
(define-key global-map (kbd "s-m") 's-m-prefix)
(fset 's-m-prefix s-m-map)
#+END_SRC

** Custom keybindings

#+BEGIN_SRC emacs-lisp
;; create a custom minor mode to override other keybindings and use mine instead
(defvar key-minor-mode-map (make-keymap) "key-minor-mode keymap.")
(define-minor-mode key-minor-mode
  "A minor mode so that my key settings override annoying major modes."
  t " key" 'key-minor-mode-map)
(key-minor-mode 1)
(defun my-minibuffer-setup-hook ()
  (key-minor-mode 0))
(add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)

;; unbind some existing keybindings 
(define-key undo-tree-map (kbd "C-x r") nil)

;; and the keybindings 
;; mk - mykeybindings

(define-key key-minor-mode-map (kbd "s-v") 'pasteboard-paste)
(define-key key-minor-mode-map (kbd "s-x") 'pasteboard-cut)
(define-key key-minor-mode-map (kbd "s-c") 'pasteboard-copy)

;; pop mark
(define-key key-minor-mode-map (kbd "C-x p")'pop-to-mark-command)

;; projectile
(define-key key-minor-mode-map (kbd "s-P") 'projectile-commander)

;; and make it work in the minibuffer too
(define-key minibuffer-local-map (kbd "s-v") 'pasteboard-paste)
(define-key minibuffer-local-map (kbd "s-x") 'pasteboard-cut)
(define-key minibuffer-local-map (kbd "s-c") 'pasteboard-copy)

(define-key key-minor-mode-map (kbd "C-c C-v") 'refile-region)
(define-key key-minor-mode-map (kbd "H-w") 'widen)
(define-key key-minor-mode-map (kbd "C-c e") 'eval-buffer)
(define-key key-minor-mode-map (kbd "C-c r") 'eval-region)
(define-key key-minor-mode-map (kbd "C--") 'goto-last-change) ; super useful when editing
(define-key key-minor-mode-map (kbd "C-d") 'kill-word-correctly)
(define-key key-minor-mode-map (kbd "C-j") 'prelude-top-join-line)
(define-key key-minor-mode-map (kbd "=") 'smex) ; call any function with easiest keystroke possible
(define-key key-minor-mode-map (kbd "M-x") 'helm-M-x) ; call helm-M-x instead of regular M-x
(define-key key-minor-mode-map (kbd "\|") 'deft)

(define-key key-minor-mode-map (kbd "M-K") 'kill-clause)

(define-key key-minor-mode-map (kbd "M-8") 'org-toggle-heading)


(define-key key-minor-mode-map (kbd "M--") 'cycle-hyphenation)

(define-key key-minor-mode-map (kbd "C-c j") 'helm-org-headlines) ; also bound to keychord jj
(define-key key-minor-mode-map (kbd "C-x b") 'helm-mini) ; shows recent files; also bound to ⌘-r 
(define-key key-minor-mode-map (kbd "M-b M-d") 'book-dired) ; show directory of my book folder
(define-key key-minor-mode-map (kbd "M-b r") 'read-a-book) ; show directory of my PDF books 
(define-key key-minor-mode-map (kbd "M-b j") 'read-jd) ; show PDF books I have annotated
(define-key key-minor-mode-map (kbd "M-b M-b") 'work-on-book) ; 

(define-key key-minor-mode-map (kbd "M-b M-w") 'work-on-book) ; 

;; book bindings
(define-key key-minor-mode-map (kbd "M-b M-p") 'book-proposal-directory) ; go to my book folder
(define-key key-minor-mode-map (kbd "M-b M-r") 'book-helm-strict) ; this is a smart function, show recent files in my book folder

;; can't get this to work. for some reason GNU Emacs interprets ⌘-shift-d as s-c
(define-key key-minor-mode-map (kbd "s-D") 'diredp-dired-recent-dirs) 

;; recent directories... but how to populate it?
(define-key key-minor-mode-map (kbd "C-S-d") 'diredp-dired-recent-dirs) 

;; own structure editing
(define-key key-minor-mode-map (kbd "C-c C-`") 'move-region-to-other-window) ; very useful when working with a split frame

;; (define-key key-minor-mode-map (kbd "C-c C-w") 'org-refile) ; very useful when working with a split frame

;; for extracting content from my browser
(define-key key-minor-mode-map (kbd "s-W") 'web-research)
(define-key key-minor-mode-map (kbd "s-I") 'web-research-quotes)
(define-key key-minor-mode-map (kbd "s-V") 'kdm/html2org-clipboard) ; paste HTML content that I've copied from the web, automatically converting to proper org-mode syntax


;; and the keybinding
(define-key org-mode-map (kbd "C-k") 'my/kill-line-dwim)


;; use OSX standard keybindings ⌘-up and ⌘-down to go to top or bottom of buffer
(define-key key-minor-mode-map [s-up] 'beginning-of-buffer)
(define-key key-minor-mode-map [s-down] 'end-of-buffer)

;; use OSX standard keybinding for "Redo"
(define-key key-minor-mode-map (kbd "s-y") 'undo-tree-redo)

;; use OSX standard keybinding to increase or decrease font size 
(define-key key-minor-mode-map (kbd "s-=") 'text-scale-increase)
(define-key key-minor-mode-map (kbd "s--") 'text-scale-decrease)

;; rebind global help command so that I can use C-h for backspace
(define-key key-minor-mode-map (kbd "M-h") 'help-command)

;; very useful when encountering names and other unfamiliar words
(define-key key-minor-mode-map (kbd "M-+") 'add-word-to-personal-dictionary)

;; navigate between buffers, including uninteresting ones that are hidden by default
(define-key key-minor-mode-map (kbd "M-s-<right>") 'switch-to-next-buffer)
(define-key key-minor-mode-map (kbd "M-s-<left>") 'previous-buffer)

;; deleting things
(define-key key-minor-mode-map (kbd "<backspace>") 'my/delete-backward)

;; a keybinding for "delete" in addition to "backspace"
(define-key key-minor-mode-map (kbd "C-<backspace>") 'delete-char)
(define-key key-minor-mode-map (kbd "M-<backspace>") 'backward-kill-word-correctly)
 
;; pomodoro
(define-key key-minor-mode-map (kbd "C-c C-x pi") 'pomodoro-start)
(define-key key-minor-mode-map (kbd "C-c C-x po") 'pomodoro-stop)

;; find files using helm
(define-key key-minor-mode-map (kbd "C-x C-f") 'helm-find-files) 

;; search using helm-swoop
(global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
(global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
(global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)
(global-set-key (kbd "M-i") 'helm-multi-swoop-all)

;; edit Emacs preferences using standard OSX keybinding for preferences
(define-key key-minor-mode-map (kbd "s-,") 'customize-group)

;; grep, using current folder as default
(define-key key-minor-mode-map (kbd "s-G") 'helm-do-grep)

;; some custom functions
(define-key key-minor-mode-map (kbd "C-c C-m") 'move-region-to-other-window)
#+END_SRC

** keybindings not currently in use 
 (define-key key-minor-mode-map (kbd "DEL")  'new-org-delete-backward-char)
 (global-set-key (kbd "C-c s") 'org-copy-subtree)
 (define-key key-minor-mode-map (kbd "C-v s") 'org-paste-subtree)
 (define-key key-minor-mode-map (kbd "s-l") 'org-insert-link)
 (define-key key-minor-mode-map (kbd "s-i") 'markdown-insert-image)
 (define-key key-minor-mode-map (kbd "s-\\") 'org-ctrl-c-ctrl-c)
 (define-key key-minor-mode-map (kbd "s-u") 'ido-dired)
 (define-key key-minor-mode-map (kbd "H-n") 'org-narrow-to-subtree)
 (define-key key-minor-mode-map (kbd "H-w") 'widen)
 (define-key key-minor-mode-map (kbd "H-G") 'prelude-google)
 (define-key key-minor-mode-map (kbd "s-G") 'osx-browse-guess)
 (define-key key-minor-mode-map (kbd "s-L") 'org-mac-chrome-insert-frontmost-url)
 (define-key key-minor-mode-map (kbd "s-") 'google-define-word-or-phrase)
 (define-key key-minor-mode-map (kbd "C-c C-x C-o") 'org-pomodoro)
 (define-key key-minor-mode-map (kbd "s-R") 'web-research)
 (define-key key-minor-mode-map (kbd "s-v") 'clipboard-yank) 


;; (define-key key-minor-mode-map (kbd "<right>") 'aquamacs-right-char)
;; (define-key key-minor-mode-map (kbd "<right>") 'switch-to-next-buffer)
;; (define-key key-minor-mode-map (kbd "<right>") 'switch-to-next-buffer)
;; (define-key key-minor-mode-map (kbd "<down>") 'aquamacs-next-line)




* Sentences

Make ~kill-sentence~ work in a more intuitive way:
#+BEGIN_SRC emacs-lisp
(defun kill-sentence-to-period ()
  "Leave the period in there."
  (interactive)
  (kill-sentence)
  (push-mark)
  (insert ".")
  (backward-char))
#+END_SRC

[[http://emacs.stackexchange.com/questions/12266/how-change-behavior-of-kill-sentence-based-on-position-in-sentence/12321?iemail=1&noredirect=1#12321][Source]]

#+BEGIN_SRC emacs-lisp
(defun my/forward-to-sentence-end ()
  "Move point to just before the end of the current sentence."
  (forward-sentence)
  (backward-char)
  (unless (looking-back "[[:alnum:]]")
    (backward-char)))

(defun my/beginning-of-sentence-p ()
  "Return  t if point is at the beginning of a sentence."
  (let ((start (point))
        (beg (save-excursion (forward-sentence) (forward-sentence -1))))
    (eq start beg)))

(defun my/kill-sentence-dwim ()
  "Kill the current sentence up to and possibly including the punctuation.
When point is at the beginning of a sentence, kill the entire
sentence. Otherwise kill forward but preserve any punctuation at the sentence end."
  (interactive)
(expand-abbrev)
  (if (my/beginning-of-sentence-p)
      (progn
        (kill-sentence)
        (just-one-space)
        (when (looking-back "^[[:space:]]+") (delete-horizontal-space)))
      (kill-region (point) (progn (my/forward-to-sentence-end) (point)))
      (just-one-space 0)))

;; and the keybinding
(global-set-key (kbd "M-k") 'my/kill-sentence-dwim)

(defun my/kill-line-dwim ()
  "Kill the current line."
  (interactive)
(expand-abbrev)
(org-kill-line)
(my/fix-space))
#+END_SRC

* Browsing

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
#+END_SRC

* Pastebin

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/gnulisp/emacs-pastebin-master/")
(require 'neopastebin)
(pastebin-create-login :dev-key "e5ccb53890f16065d90ebd6064a381d0"
                       :username "petersalazar")
#+END_SRC

* Custom functions

#+BEGIN_SRC emacs-lisp 
(defun my/fix-space ()
"Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
(interactive)
(just-one-space)
(when (or (looking-back "^[[:space:]]+") 
(looking-at "[[:punct:]]"))
(delete-horizontal-space))) 
#+END_SRC



** forward kill word correctly
#+BEGIN_SRC emacs-lisp
;;; old version; remove after testing new one below
;; (defun kill-word-correctly ()
;;   "Kill word."
;;   (interactive)
;;   (expand-abbrev)
;;   (if (not(looking-at "[[:punct:]]")) ; if character at point is NOT a punctuation mark
;;     (progn                            ; THEN
;;   (kill-word 1) ; kill word
;;   (my/fix-space)) ; and fix space
;; (progn ; else 
;; (delete-forward-char 1) ; just delete the punctuation mark
;; (my/fix-space) ; and delete the space as well
;; )
;; ))

;;; new version
(defun kill-word-correctly ()
  "Kill word."
  (interactive)
  (expand-abbrev)
  (if (re-search-forward "\\=\\W*[[:punct:]]+\\W*\\<" nil t) ; IF there's a sequence of punctuation marks at point
      (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
    (kill-word 1))                                    ; ELSE kill word
  (my/fix-space)) ; and finally fix space
#+END_SRC


** BACKWARD kill word correctly 

#+BEGIN_SRC emacs-lisp
;;; old version; remove after testing new one below
;; (defun backward-kill-word-correctly ()
;;   "Kill word."
;;   (interactive)
;;   (let ((old-point (point)))
;;     (if (re-search-backward "[[:punct:]]+\\W*\\=" nil t)
;;         ;; old-point should be > (point); this makes it prefix append
;;         ;; to kill-ring
;;         (kill-region old-point (point))
;;       (backward-kill-word 1)))
;;   (my/fix-space)
;;   (jay/insert-space) ; I added this line, I think it works.
;; ) 

;;; new version
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)
  (jay/insert-space) ; I added this line, I think it works.
  )
#+END_SRC

*** my delete backward
#+BEGIN_SRC emacs-lisp
;; delete backward one char unless the region is active: 
(defun my/delete-backward ()
"When there is an active region, delete it and then fix up the whitespace"
  (interactive)
  (if (use-region-p)                  ; IF
    (progn                            ; THEN
      (delete-region (region-beginning) (region-end))
      (my/fix-space)) 
(progn ; ELSE 
    (delete-backward-char 1)
(when (or (looking-back "^[[:space:]]+") 
(looking-at "[[:punct:]]"))
(delete-horizontal-space)) 
)
)
) 


(defun timesvr ()
  "Task request to my virtual assistant."
  (interactive)
  (message-mail)
  (message-goto-subject) (insert "task request: " (format-time-string "%F %l:%M%P"))
  (message-goto-body) (insert "\n")
  )
(global-set-key (kbd "C-c t") 'timesvr)
(global-set-key (kbd "C-c m") 'compose-mail)
#+END_SRC

* Startup

#+BEGIN_SRC emacs-lisp
(toggle-maxframe)
(monaco-font)
#+END_SRC

* character movement
#+BEGIN_SRC emacs-lisp

(defun jay/left-char ()
  "Move point to the left or the beginning of the region.
 Like `backward-char', but moves point to the beginning of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'left-char)) ;; maintain compatibility
    (let ((left (min (point)
                     ;; `mark' returning nil is ok; we'll only use this
                     ;; if `mark-active'
                     (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn
            (goto-char left)
            (setq deactivate-mark t))
        (call-interactively 'left-char)))))


(defun jay/right-char ()
  "Move point to the right or the end of the region.
 Like `right-char', but moves point to the end of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'right-char)) ;; maintain compatibility
    (let ((right (max (point)
                      ;; `mark' returning nil is ok; we'll only use this
                      ;; if `mark-active'
                      (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn (goto-char right)
		 (setq deactivate-mark t))
	(call-interactively 'right-char)))))

(define-key org-mode-map (kbd "<left>") 'jay/left-char)
(define-key org-mode-map (kbd "<right>") 'jay/right-char)

#+END_SRC


* experiments
#+BEGIN_SRC emacs-lisp
(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)
 
(define-key org-mode-map (kbd "<SPC>") 'jay/insert-space)


#+END_SRC



* Helm Org Wiki

I'm using an extremely simplistic approach: just dump all the org
files into one directory.  The name of each org file should be concise
but descriptive, e.g. Makefile.org describes Makefiles, and git.org
describes git.

This simplicity completely alleviates organization effort: there's
nothing to organize, since there's only one directory to put the files in.
At the same time, it's very accessible by means of two `helm` wrappers:

- globally, "C-0" runs the command helm-org-wiki (the code is below)
- in org-mode, "g" runs the command wspecial-worf-goto (the code is at
https://github.com/abo-abo/worf)

It's like a two-stage personal Google: the first stage is to find an org-file,
the second stage is to search within an org-file.

For example, here's the sequence of key bindings when I want to look
up how git bisect works, assuming that I'm in some random buffer, like
`ansi-term`:

        C-0 gi RET g bis RET

Done. Note that "gi" was enough to match "git.org", since all my other
pages don't contain "gi".  Same thing for "bis" being able to match
uniquely the heading "git bisect".  I think that it's quite optimal
that I'm able to find the topic "git bisect" by using only 10 key
presses, which is the same as the amount of characters in "git
bisect".  Compare this to `helm-google-suggest` (bound to "C-p g"):

        C-p g git bi RET TAB RET

That's 12 key presses (10 in Emacs, 2 in Firefox).

New wiki pages can be created with "C-0" as well, just type in the
name of the new file and hit RET.

That's it, the code is below. It's very similar to `org-switchb`,
except that the files need not be opened to appear in the completion
list, and new files are created if there's no match.

regards,
Oleh
(Source: http://lists.gnu.org/archive/html/emacs-orgmode/2014-04/msg01134.html) 

#+BEGIN_SRC emacs-lisp 
    (defgroup helm-org-wiki nil
      "Simple jump-to-org-file package."
      :group 'org
      :prefix "helm-org-wiki-")
    (defcustom helm-org-wiki-directory "~/nd/"
      "Directory where files for `helm-org-wiki' are stored."
      :group 'helm-org-wiki
      :type 'directory)
    (defun helm-org-wiki-files ()
      "Return .org files in `helm-org-wiki-directory'."
      (let ((default-directory helm-org-wiki-directory))
        (mapcar #'file-name-sans-extension
                (file-expand-wildcards "*.txt"))))
    (defvar helm-source-org-wiki
      `((name . "Projects")
        (candidates . helm-org-wiki-files)
        (action . ,(lambda (x)
                      (find-file (expand-file-name
                                  (format "%s.txt" x)
                                  helm-org-wiki-directory))))))
    (defvar helm-source-org-wiki-not-found
      `((name . "Create org-wiki")
        (dummy)
        (action . (lambda (x)
                    (helm-switch-to-buffer
                     (find-file
                      (format "%s/%s.org"
                              helm-org-wiki-directory x)))))))
    ;;;###autoload
    (defun helm-org-wiki ()
      "Select an org-file to jump to."
      (interactive)
      (helm :sources
            '(helm-source-org-wiki
              helm-source-org-wiki-not-found)))
    (provide 'helm-org-wiki)

#+END_SRC


* Emacs Lisp Mode
#+BEGIN_SRC emacs-lisp 
(defun turn-on-autocomplete-mode ()
   (auto-complete-mode 1))
(add-hook 'emacs-lisp-mode-hook 'turn-on-autocomplete-mode )
#+END_SRC
 
* Reference for cleaning up whitespace around sentences:
[[http://stackoverflow.com/questions/4754547/redefining-sentence-in-emacs-single-space-between-sentences-but-ignoring-ab][regex - Redefining "sentence" in Emacs? (single space between sentences, but ignoring abbreviations) - Stack Overflow]]

* cycle-hyphenation 

#+BEGIN_SRC emacs-lisp
(defun cycle-hyphenation ()
  (interactive)
  (cond ((re-search-forward "\\=\\W*\\w+\\(-\\)\\w+" nil t)
         (save-excursion (replace-match " " t t nil 1)))
        ((re-search-forward "\\=\\W*\\w+\\( +\\)\\w+" nil t)
         (save-excursion (replace-match "-" t t nil 1)))))
#+END_SRC

* Org clone subtree

#+BEGIN_SRC emacs-lisp
(defun org-clone-subtree ()
  (interactive)
  (org-clone-subtree-with-time-shift 1)
  (save-excursion
    (org-goto-sibling)
    ;; This part was lifted partly and adapted from
    ;; http://orgmode.org/worg/org-hacks.html#orgheadline10.
    ;; There should be a better way to change the contents of an org heading
    ;; though...
    (when (org-at-heading-p)
      (let ((hl-text (nth 4 (org-heading-components)))
            (buffer-undo-list))
        (when hl-text
          (beginning-of-line)
          (search-forward hl-text (point-at-eol))
          (replace-match (format "%s - clone" hl-text) nil t)
          (org-align-tags-here org-tags-column))))))
#+END_SRC


* TODO Request                                                         :rudi:
For the above whitespace and sentence functions, can we make it so that Emacs will recognize three hyphens in a row---as punctuation same as a comma?

** DONE Request for clarification                                  :followup:

   Not sure which functions you mean. The ones in the "Sentences" Heading?
** DONE Answer                                                         :rudi:
- my/fix-space
- kill-clause
- my-delete-backward
- kill-word-correctly
- backward-kill-word-correctly

Basically I'd like to make it so that org-mode treats --- as a singles punctuation mark in any function that looks for :punct: 

*** Example                                                          :rudi:
Take a look at the function kill-word-correctly. I want it so that kill-word-correctly counts --- as a word. 

Take this sentence below:

: The quick brown fox jumped---jumped high.

In the sentence above, if I place the point on the "h" in "high" and then do kill-word-correctly TWICE, it should first delete the word jumped and fix the space, and THEN on the second invocation, it should deletes the unwanted --- and fix the space.

So the first invocation should result in this:

: The quick brown fox jumped---high. 

...and second invocation should then delete the --- and fix the space so the result is this:

: The quick brown fox jumped high. 

Thanks!

*** DONE Note & question                                               :rudi:

    OK. But it is not straightforward. You see, [:punct:] denotes a set of characters; --- a *sequence* of characters. It is not simply a case of changing the meaning of [:punct:]. I don't see a way to do it other than changing each function individually.

    However, according to the syntax table of my org-mode, - is considered a punctuation. So if I ~kill-word-correctly~ over "open-source" (point on 'o'), I then get "-source", and if I do it again, I get "source". Is that the same for you? 

: Yes it is. 

    If that is the case, then would killing all *consecutive* punctuation marks cover this case? What about "--", "?!", "...?" (and possibly other consecutive punctuation marks, like "--," - some authors like that style)? They would also be killed completely. Is that according to your requirements?

: Yes, automatically killing all consecutive punctuation in cases like "---" "--", "?!", and "...?" would certainly be according to my requirements. So yes, I think that solves the problem! Thank you!

** TODO More questions                                             :followup:

   - ~my/fix-space~
     - What should be the difference here?

: The difference is that there should be a space after ; : , ? ! or . but no space after ---

   - ~kill-clause~
     - Since this is already sensitive to --, it should also be sensitive to ---. It should also be sensitive to other sequences of punctuation marks. Let me know otherwise.

: Excellent.

   - ~my/delete-backward~
     - Again, I don't think this requires any change. It deletes all spaces when it is looking at a punctuation mark. Since - is a punctuation mark, any space before --- will also be deleted.

: Correct. I think the difference is the space following ---

   - ~kill-word-correctly~ & ~backward-kill-word-correctly~
     - Regarding these two functions, I have added new versions of them. Note however that they tend to fsck up the kill-ring, because of their calls to ~my/fix-space~. This already occurred in the old versions. Consider the following example:

: Kill them all!

   If you place the point at 'K', and call ~kill-word-correctly~ four times, all of the text will be killed. After killing each word, two consecutive spaces are left, and ~my/fix-space~ will get rid of one. However, ~my/fix-space~ is not a kill command, so it does not affect the kill-ring. Consequently, if you yank after killing all the words, you'll get:

: Killthemall!

   Would you like me to try to fix this or is the kill ring really not your concern?

: Haha, no, this is not a problem! Thank you! 

* TODO request: smart punctuation insertion                             :rudi:
Rúdi, can you add a line to the functions below that will automatically delete existing punctuation when one of these smart-punctuation functions gets called?

I'll give you an example of what I mean. Consider this sentence:

: The rain in Spain falls mainly on the plains! 

Let's say the point is on the space after the ! at the end of the sentence.

If I then hit ? (which calls smart-question-mark), Emacs should DELETE the existing ! and then replace it with a ? (and then put a space after it).

The logic of this is that I will NEVER be trying to type anything like:

- Hello!?
- Hello.!
- Hello?.
- Hello,.
- Hello.,

In other words, if the point is after a ; : , ! ? or . and then I hit a punctuation mark, it's almost certain that I am doing this because I wish to CHANGE the punctuation and not ADD one punctuation mark after another. 

** Exceptions
1. I will often want to type three dots like so:
: To be continued...
2. or occasionally a question mark followed by an exclamation point like so:
: What the hell?!
3. I still need to be able to indicate em dashes---that is, three hyphens in a row.

Is this straightforward to implement, or do the exceptions create a lot of complications? Exception #2 is very rare, so if it creates problems we can forget about it. Really #1 and #3 are the important ones.

** smart-period
#+BEGIN_SRC emacs-lisp 
(defun smart-period ()
  (interactive)
(expand-abbrev)
(when (looking-back "[[:space:]]+") (delete-horizontal-space))
; TODO also delete existing punctuation 
(insert ".")
)
(define-key org-mode-map (kbd ".") 'smart-period)
#+END_SRC

** smart-comma
#+BEGIN_SRC emacs-lisp 
(defun smart-comma ()
  (interactive)
(expand-abbrev)
(when (looking-back "[[:space:]]+") (delete-horizontal-space))
; TODO also delete existing punctuation 
(insert ",")
)
(define-key org-mode-map (kbd ",") 'smart-comma)
#+END_SRC

** smart-question-mark
#+BEGIN_SRC emacs-lisp 
(defun smart-question-mark ()
  (interactive)
(expand-abbrev)
(when (looking-back "[[:space:]]+") (delete-horizontal-space))
; TODO also delete existing punctuation 
(insert "?")
)
(define-key org-mode-map (kbd "?") 'smart-question-mark)
#+END_SRC

** smart-exclamation-point
#+BEGIN_SRC emacs-lisp 
(defun smart-exclamation-point ()
  (interactive)
(expand-abbrev)
(when (looking-back "[[:space:]]+") (delete-horizontal-space))
; TODO also delete existing punctuation 
(insert "!")
)
(define-key org-mode-map (kbd "!") 'smart-exclamation-point)
#+END_SRC



