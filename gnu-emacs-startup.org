#+TITLE: Jay Dixit's GNU Emacs setup
* About
  - System: Mac OSX Yosemite
  - Emacs version: 24.5.1
  - Use case: GNU Emacs specific settings.

* Handle Emacs UTF-8 input

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setenv "LANG" "en_US.UTF-8")
#+END_SRC

* Sticky windows

#+BEGIN_SRC emacs-lisp
(global-set-key [(control x) (?0)] 'delete-other-windows)
(global-set-key [(control x) (?9)] 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-0") 'delete-window)
(global-set-key  (kbd "s-1") 'delete-other-windows)
(global-set-key  (kbd "s-9") 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-2") 'split-window-vertically)
(global-set-key  (kbd "s-3") 'split-window-horizontally)
#+END_SRC

* Abbreviations (autocorrect)

Automatically load abbreviations table:
#+BEGIN_SRC emacs-lisp
(setq-default abbrev-mode t)
(read-abbrev-file "~/Dropbox/elisp/.abbrev_defs") 
(set (make-local-variable 'abbrev-file-name) (expand-file-name "~/Dropbox/elisp/own-abbrevs.abbrev_defs")) 
(read-abbrev-file "~/Dropbox/elisp/own-abbrevs.abbrev_defs")
(setq save-abbrevs t)
(setq only-global-abbrevs t)
#+END_SRC

* UI/Appearance

Clean UI:
#+BEGIN_SRC emacs-lisp
(tooltip-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode 1)
#+END_SRC

Don't highlight lines:
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
          (lambda()
            (hl-line-mode -1)
            (global-hl-line-mode -1))
          't
          )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq prelude-whitespace nil)
#+END_SRC

Wrap text:
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode)
#+END_SRC

* Fullscreen settings

[[http://amitp.blogspot.ca/2008/05/emacs-full-screen-on-mac-os-x.html][(Source)]]

#+BEGIN_SRC emacs-lisp
(defvar maxframe-maximized-p nil "maxframe is in fullscreen mode")

(defun toggle-maxframe ()
  "Toggle maximized frame"
  (interactive)
  (setq maxframe-maximized-p (not maxframe-maximized-p))
  (cond (maxframe-maximized-p (maximize-frame))
        (t (restore-frame))))

(define-key global-map [(s-return)] 'toggle-maxframe)
;; make it easy to go fullscreen
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

;; and the keybinding 
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f11>") 'toggle-fullscreen))
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f13>") 'toggle-fullscreen))

  (global-set-key (kbd "<f13>") 'toggle-fullscreen)
#+END_SRC

* Directory settings

There is probably a lot of redundancy here, I don't understand this stuff too
well.

#+BEGIN_SRC emacs-lisp
(defun mydired-sort ()
  "Sort dired listings with directories first."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
    (set-buffer-modified-p nil)))

(defadvice dired-readin
  (after dired-after-updating-hook first () activate)
  "Sort dired listings with directories first before adding marks."
  (mydired-sort)
  (let ((dired-details-internal-overlay-list  ())) (dired-details-hide)))

(add-hook 'dired-load-hook
	  (lambda ()
(require 'dired-sort-menu)))


(defcustom dired-details-hidden-string ""
  "*This string will be shown in place of file details and symbolic links."
  :group 'dired-details
  :type 'string)

(defcustom dired-details-initially-hide t
  "*Hide dired details on entry to dired buffers."
  :group 'dired-details
  :type 'boolean)
#+END_SRC

 omit certain specific uninteresting file types from dired
#+BEGIN_SRC emacs-lisp

(require 'dired-x)
(setq-default dired-omit-files-p t) ; this is buffer-local variable


;; (setq dired-omit-files "^\\.[^.]\\|\\.pdf$\\|\\.tex$\\|\\.DS_Store\\|\\.doc$\\|\\.docx$\\|\\.xlsx$\\|\\.ini$\\|\\.fsLockFile$\\|Icon")

(setq dired-omit-files "^\\.[^.]\\|\\.pdf$\\|\\.tex$\\|\\.DS_Store$\\|\\.doc$\\|\\.docx$\\|\\.ini$\\|\\.rtf$\\|\\Icon$")

;; Enable toggling of uninteresting files.
(setq dired-omit-mode t)
(setq-default dired-omit-files-p t) ; this is buffer-local variable

(defun enable-dired-omit-mode () (dired-omit-mode 1))
(add-hook 'dired-mode-hook 'enable-dired-omit-mode)


;; Load Dired X when Dired is loaded.
(add-hook 'dired-load-hook '(lambda () (require 'dired-x)))

;; so that I can hide details on dired
(require 'dired-details+)
#+END_SRC

* Other functions

Manually remove the scrollbar if default setting fails when creating a new frame:

#+BEGIN_SRC emacs-lisp
(defun scrollbar-init ()
  (interactive)
  (scroll-bar-mode -1)
  )
#+END_SRC


Forgot what this does, I think it's in case Emacs crashes maybe to recover
autosaves?
#+BEGIN_SRC emacs-lisp
(defadvice recover-session (around disable-dired-omit-for-recover activate)
  (let ((dired-mode-hook dired-mode-hook))
    (remove-hook 'dired-mode-hook 'enable-dired-omit-mode)
    ad-do-it))
#+END_SRC

* Isolate Emacs kill ring from the OSX system pasteboard (clipboard).

Very important, I use this all the time.  These are custom functions to separate
the OSX clipboard from Emacs' kill ring, effectively giving me two separate
clipboards to work from. The below are the traditional OSX keybindings for
cut/copy/paste, and they will now work with the OSX clipboard. The yank and pop functions still work, and use the Emacs kill ring instead.


** Setup
#+BEGIN_SRC emacs-lisp
(setq interprogram-cut-function nil)
(setq interprogram-paste-function nil)
#+END_SRC
 
** pasteboard-copy
#+BEGIN_SRC emacs-lisp

(defun pasteboard-copy()
  "Copy region to OS X system pasteboard."
  (interactive)
  (shell-command-on-region
   (region-beginning) (region-end) "pbcopy"))
#+END_SRC

** pasteboard-paste

#+BEGIN_SRC emacs-lisp 
;;; old version; remove after testing new one (see below)
;; (defun pasteboard-paste()
;;   "Paste from OS X system pasteboard via `pbpaste' to point."
;;   (interactive)
;; (my/fix-space)
;;   (shell-command-on-region
;;    (point) (if mark-active (mark) (point)) "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'" nil t)
;; (my/fix-space)
;; ;; (when (looking-back "^[[:space:]]+") (just-one-space)) ; this didn't work
;; )

;;; new version; not thoroughly tested
(defun pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
        (end (if mark-active
                 (mark)
               (point))))
    (shell-command-on-region start end
                             "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
                             nil t)
    (my/fix-space)
    (save-excursion
      (goto-char start)
      (my/fix-space))))
#+END_SRC

** minibuffer-pasteboard-paste

#+BEGIN_SRC emacs-lisp 
(defun minibuffer-pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
	(end (if mark-active
		 (mark)
	       (point))))
    (shell-command-on-region start end
			     "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
			     nil t)

    (save-excursion

      )))
#+END_SRC

** pasteboard-cut

#+BEGIN_SRC emacs-lisp 
(defun pasteboard-cut()
  "Cut region and put on OS X system pasteboard."
  (interactive)
  (pasteboard-copy)
  (delete-region (region-beginning) (region-end))
(my/fix-space)
)
#+END_SRC

* Keybindings

** Create custom keybinding prefix 

#+BEGIN_QUOTE
I have an unconventional approach to this that I recommend highly. I have redefined the C-l ('ell') key to be a prefix key, and I use that to prefix my favorite commands. This key is very easy to type and it is bound to a function ('recenter) that isn't used that much. Well, I don't use 'recenter much, but even if you did, it can be assigned to C-l C-l which is almost as easy to type, and a small price to pay for the possibilities opened up by the Ctrl-L-map. (Actually I prefer 'redraw-display to 'recenter, so I gave that the place of honor.)
#+END_QUOTE
Source: [[http://stackoverflow.com/questions/5682631/what-are-good-custom-keybindings-in-emacs/5682737#5682737][ LenW's answer on keyboard - What are good custom keybindings in emacs? - Stack Overflow]]

Use ⌘-m as prefix for my own custom keybindings:
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "s-m"))
(defvar s-m-map (make-keymap)
  "Keymap for local bindings and functions, prefixed by (Command-M)")
(define-key global-map (kbd "s-m") 's-m-prefix)
(fset 's-m-prefix s-m-map)
#+END_SRC

** Custom keybindings

#+BEGIN_SRC emacs-lisp
;; create a custom minor mode to override other keybindings and use mine instead
(defvar key-minor-mode-map (make-keymap) "key-minor-mode keymap.")
(define-minor-mode key-minor-mode
  "A minor mode so that my key settings override annoying major modes."
  t " key" 'key-minor-mode-map)
(key-minor-mode 1)
(defun my-minibuffer-setup-hook ()
  (key-minor-mode 0))
(add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)

;; unbind some existing keybindings 
(define-key undo-tree-map (kbd "C-x r") nil)

;; and the keybindings
;; mk - mykeybindings

(define-key key-minor-mode-map (kbd "s-v") 'pasteboard-paste)
(define-key key-minor-mode-map (kbd "s-x") 'pasteboard-cut)
(define-key key-minor-mode-map (kbd "s-c") 'pasteboard-copy)

(define-key minibuffer-local-map (kbd "s-v") 'minibuffer-pasteboard-paste)

(define-key key-minor-mode-map (kbd "s-Z") 'unexpand-abbrev)

(global-unset-key (kbd "C-S-r")) 
(define-key key-minor-mode-map (kbd "C-S-r") nil)
(define-key org-mode-map (kbd "C-S-r") nil)


;; pop mark
(define-key key-minor-mode-map (kbd "C-x p")'pop-to-mark-command)

;; projectile
(define-key key-minor-mode-map (kbd "s-P") 'projectile-commander)

;; and make it work in the minibuffer too
(define-key minibuffer-local-map (kbd "s-v") 'pasteboard-paste)
(define-key minibuffer-local-map (kbd "s-x") 'pasteboard-cut)
(define-key minibuffer-local-map (kbd "s-c") 'pasteboard-copy)

(define-key key-minor-mode-map (kbd "C-c C-v") 'refile-region)
(define-key key-minor-mode-map (kbd "H-w") 'widen)
(define-key key-minor-mode-map (kbd "C-c e") 'eval-buffer)
(define-key key-minor-mode-map (kbd "C-c r") 'eval-region)
(define-key key-minor-mode-map (kbd "C--") 'goto-last-change) ; super useful when editing
(define-key key-minor-mode-map (kbd "C-d") 'kill-word-correctly-and-capitalize)
(define-key key-minor-mode-map (kbd "C-j") 'prelude-top-join-line)


(define-key key-minor-mode-map (kbd "C-S-l") 'reflash-indentation)
(define-key key-minor-mode-map (kbd "C-l") 'recenter-top-bottom)


(define-key key-minor-mode-map (kbd "=") 'smex) ; call any function with easiest keystroke possible
(define-key key-minor-mode-map (kbd "M-x") 'helm-M-x) ; call helm-M-x instead of regular M-x
(define-key key-minor-mode-map (kbd "\|") 'deft)

(define-key key-minor-mode-map (kbd "M-K") 'kill-clause)

(define-key key-minor-mode-map (kbd "M-8") 'org-toggle-heading)

(define-key key-minor-mode-map (kbd "C-t") 'transpose-words)

(define-key key-minor-mode-map (kbd "M--") 'cycle-hyphenation)

(define-key key-minor-mode-map (kbd "C-c j") 'helm-org-headlines) ; also bound to keychord jj
(define-key key-minor-mode-map (kbd "C-x b") 'helm-mini) ; shows recent files; also bound to ⌘-r 
(define-key key-minor-mode-map (kbd "M-b M-d") 'book-dired) ; show directory of my book folder
(define-key key-minor-mode-map (kbd "M-b r") 'read-a-book) ; show directory of my PDF books 
(define-key key-minor-mode-map (kbd "M-b j") 'read-jd) ; show PDF books I have annotated
(define-key key-minor-mode-map (kbd "M-b M-b") 'work-on-book) ; 

(define-key key-minor-mode-map (kbd "M-b M-w") 'work-on-book) ; 

;; book bindings
(define-key key-minor-mode-map (kbd "M-b M-p") 'book-proposal-directory) ; go to my book folder
(define-key key-minor-mode-map (kbd "M-b M-r") 'book-helm-strict) ; this is a smart function, show recent files in my book folder

;; can't get this to work. for some reason GNU Emacs interprets ⌘-shift-d as s-c
(define-key key-minor-mode-map (kbd "s-D") 'diredp-dired-recent-dirs) 

;; recent directories... but how to populate it?
(define-key key-minor-mode-map (kbd "C-S-d") 'diredp-dired-recent-dirs) 

;; own structure editing
(define-key key-minor-mode-map (kbd "C-c C-`") 'move-region-to-other-window) ; very useful when working with a split frame

;; (define-key key-minor-mode-map (kbd "C-c C-w") 'org-refile) ; very useful when working with a split frame

;; for extracting content from my browser
(define-key key-minor-mode-map (kbd "s-W") 'web-research)
(define-key key-minor-mode-map (kbd "s-I") 'web-research-quotes)
(define-key key-minor-mode-map (kbd "s-V") 'kdm/html2org-clipboard) ; paste HTML content that I've copied from the web, automatically converting to proper org-mode syntax


;; and the keybinding
(define-key org-mode-map (kbd "C-k") 'my/kill-line-dwim)


;; use OSX standard keybindings ⌘-up and ⌘-down to go to top or bottom of buffer
(define-key key-minor-mode-map [s-up] 'beginning-of-buffer)
(define-key key-minor-mode-map [s-down] 'end-of-buffer)

;; use OSX standard keybinding for "Redo"
(define-key key-minor-mode-map (kbd "s-y") 'undo-tree-redo)

;; use OSX standard keybinding to increase or decrease font size 
(define-key key-minor-mode-map (kbd "s-=") 'text-scale-increase)
(define-key key-minor-mode-map (kbd "s--") 'text-scale-decrease)

;; rebind global help command so that I can use C-h for backspace
(define-key key-minor-mode-map (kbd "M-h") 'help-command)

;; very useful when encountering names and other unfamiliar words
(define-key key-minor-mode-map (kbd "M-+") 'add-word-to-personal-dictionary)

;; navigate between buffers, including uninteresting ones that are hidden by default
(define-key key-minor-mode-map (kbd "M-s-<right>") 'switch-to-next-buffer)
(define-key key-minor-mode-map (kbd "M-s-<left>") 'previous-buffer)

;; deleting things
(define-key key-minor-mode-map (kbd "<backspace>") 'my/delete-backward)

;; a keybinding for "delete" in addition to "backspace"
(define-key key-minor-mode-map (kbd "C-<backspace>") 'delete-char)
(define-key key-minor-mode-map (kbd "M-<backspace>") 'backward-kill-word-correctly)
 
;; pomodoro
(define-key key-minor-mode-map (kbd "C-c C-x pi") 'pomodoro-start)
(define-key key-minor-mode-map (kbd "C-c C-x po") 'pomodoro-stop)

;; find files using helm
(define-key key-minor-mode-map (kbd "C-x C-f") 'helm-find-files) 

;; search using helm-swoop
(global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
(global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
(global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)
(global-set-key (kbd "M-i") 'helm-multi-swoop-all)

;; edit Emacs preferences using standard OSX keybinding for preferences
(define-key key-minor-mode-map (kbd "s-,") 'customize-group)

;; grep, using current folder as default
(define-key key-minor-mode-map (kbd "s-G") 'helm-do-grep)

;; some custom functions
(define-key key-minor-mode-map (kbd "C-c C-m") 'move-region-to-other-window)
#+END_SRC

** keybindings not currently in use 
 (define-key key-minor-mode-map (kbd "DEL")  'new-org-delete-backward-char)
 (global-set-key (kbd "C-c s") 'org-copy-subtree)
 (define-key key-minor-mode-map (kbd "C-v s") 'org-paste-subtree)
 (define-key key-minor-mode-map (kbd "s-l") 'org-insert-link)
 (define-key key-minor-mode-map (kbd "s-i") 'markdown-insert-image)
 (define-key key-minor-mode-map (kbd "s-\\") 'org-ctrl-c-ctrl-c)
 (define-key key-minor-mode-map (kbd "s-u") 'ido-dired)
 (define-key key-minor-mode-map (kbd "H-n") 'org-narrow-to-subtree)
 (define-key key-minor-mode-map (kbd "H-w") 'widen)
 (define-key key-minor-mode-map (kbd "H-G") 'prelude-google)
 (define-key key-minor-mode-map (kbd "s-G") 'osx-browse-guess)
 (define-key key-minor-mode-map (kbd "s-L") 'org-mac-chrome-insert-frontmost-url)
 (define-key key-minor-mode-map (kbd "s-") 'google-define-word-or-phrase)
 (define-key key-minor-mode-map (kbd "C-c C-x C-o") 'org-pomodoro)
 (define-key key-minor-mode-map (kbd "s-R") 'web-research)
 (define-key key-minor-mode-map (kbd "s-v") 'clipboard-yank) 


;; (define-key key-minor-mode-map (kbd "<right>") 'aquamacs-right-char)
;; (define-key key-minor-mode-map (kbd "<right>") 'switch-to-next-buffer)
;; (define-key key-minor-mode-map (kbd "<right>") 'switch-to-next-buffer)
;; (define-key key-minor-mode-map (kbd "<down>") 'aquamacs-next-line)




* Sentences

Make ~kill-sentence~ work in a more intuitive way:
#+BEGIN_SRC emacs-lisp
(defun kill-sentence-to-period ()
  "Leave the period in there."
  (interactive)
  (kill-sentence)
  (push-mark)
  (insert ".")
  (backward-char)
)
#+END_SRC

[[http://emacs.stackexchange.com/questions/12266/how-change-behavior-of-kill-sentence-based-on-position-in-sentence/12321?iemail=1&noredirect=1#12321][Source]]

#+BEGIN_SRC emacs-lisp
(defun my/forward-to-sentence-end ()
  "Move point to just before the end of the current sentence."
  (forward-sentence)
  (backward-char)
  (unless (looking-back "[[:alnum:]]")
    (backward-char)))

(defun my/beginning-of-sentence-p ()
  "Return  t if point is at the beginning of a sentence."
  (let ((start (point))
        (beg (save-excursion (forward-sentence) (forward-sentence -1))))
    (eq start beg)))

(defun my/kill-sentence-dwim ()
  "Kill the current sentence up to and possibly including the punctuation.
When point is at the beginning of a sentence, kill the entire
sentence. Otherwise kill forward but preserve any punctuation at the sentence end."
  (interactive)
(expand-abbrev)
  (if (my/beginning-of-sentence-p)
      (progn
        (kill-sentence)
        (just-one-space)
        (when (looking-back "^[[:space:]]+") (delete-horizontal-space)))
      (kill-region (point) (progn (my/forward-to-sentence-end) (point)))
      (just-one-space 0))
(when (looking-at ".. ")
(delete-forward-char 1)) 
)

;; and the keybinding
(global-set-key (kbd "M-k") 'my/kill-sentence-dwim)

(defun my/kill-line-dwim ()
  "Kill the current line."
  (interactive)
(expand-abbrev)
(org-kill-line)
(my/fix-space))
#+END_SRC

* Browsing

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
#+END_SRC

* Pastebin

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/gnulisp/emacs-pastebin-master/")
(require 'neopastebin)
(pastebin-create-login :dev-key "e5ccb53890f16065d90ebd6064a381d0"
                       :username "petersalazar")
#+END_SRC

* Custom functions

;;; old version; remove after testing new one
;; (defun my/fix-space ()
;; "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
;; (interactive)
;; (just-one-space)
;; (when (or (looking-back "^[[:space:]]+") 
;; (looking-at "[[:punct:]]"))
;; (delete-horizontal-space))) 


** my/fix-space

#+BEGIN_SRC emacs-lisp 
;;; new version
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]") 
            (looking-back "\" ") 
            (looking-at " \"")
            (looking-back"( ")
            (looking-at " )") 
            ) 
    (delete-horizontal-space)))
#+END_SRC

** kill word correctly
#+BEGIN_SRC emacs-lisp
;;; old version; remove after testing new one below
;; (defun kill-word-correctly ()
;;   "Kill word."
;;   (interactive)
;;   (expand-abbrev)
;;   (if (not(looking-at "[[:punct:]]")) ; if character at point is NOT a punctuation mark
;;     (progn                            ; THEN
;;   (kill-word 1) ; kill word
;;   (my/fix-space)) ; and fix space
;; (progn ; else 
;; (delete-forward-char 1) ; just delete the punctuation mark
;; (my/fix-space) ; and delete the space as well
;; )
;; ))

;;; new version
(defun kill-word-correctly ()
  "Kill word."
  (interactive)
  (expand-abbrev)
  (if (re-search-forward "\\=\\W*[[:punct:]]+\\W*\\<" nil t) ; IF there's a sequence of punctuation marks at point
      (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
    (kill-word 1))                                    ; ELSE kill word
  (my/fix-space)) ; and finally fix space
#+END_SRC

** 
** DONE [#A] kill word correctly and capitalize 
#+BEGIN_SRC emacs-lisp 
;;; old version; remove after testing new one
;; (defun kill-word-correctly-and-capitalize ()
;;   "Check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly."
;;   (interactive)
;; (if (my/beginning-of-sentence-p)
;;       (progn
;; (expand-abbrev)
;;   (if (re-search-forward "\\=\\W*[[:punct:]]+\\W*\\<" nil t) ; IF there's a sequence of punctuation marks at point
;;       (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
;;     (kill-word 1))                                    ; ELSE kill word
;;   (my/fix-space)
;; (capitalize-word 1) 
;; (left-word)
;; ) 
;; (progn
;; (expand-abbrev)
;;   (if (re-search-forward "\\=\\W*[[:punct:]]+\\W*\\<" nil t) ; IF there's a sequence of punctuation marks at point
;;       (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
;;     (kill-word 1))                                    ; ELSE kill word
;;   (my/fix-space)) ; and finally fix space 
;; ) 
;; )

;;; new version
(defun kill-word-correctly-and-capitalize ()
  "Check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly."
  (interactive)
  (let ((fix-capitalization (my/beginning-of-sentence-p)))
    (expand-abbrev)
    (if (re-search-forward "\\=\\W*[[:punct:]]+" nil t) ; IF there's a sequence of punctuation marks at point
        (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
      (kill-word 1))                                    ; ELSE kill word
    (my/fix-space)
    (when fix-capitalization
      (save-excursion (capitalize-word 1)))))
#+END_SRC


** TODO [#A] new BACKWARD kill word correctly                         :rudi:
Rúdi: desired behavior is that backward-kill-word-correctly should leave a space after the remaining word left of the point, UNLESS point is at the beginning of the line or after "---"

My modification below seems to work, but it seems very slow. Is it possible to make it faster? Thanks! 

#+BEGIN_SRC emacs-lisp 
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space) 

;; I added this ↓↓↓ #######################
(when (and 
(not (looking-back "---")) ; I added this 
(not (looking-back "^"))) ; I added this 
;; I added this ↑↑↑ #######################
 
(jay/insert-space) 
) 
)
#+END_SRC

** my-delete-backward                                       :rudi:
#+BEGIN_SRC emacs-lisp
;;; old versions; remove after testing new one
;; ;; delete backward one char unless the region is active: 
;; (defun my/delete-backward ()
;; "When there is an active region, delete it and then fix up the whitespace"
;;   (interactive)
;;   (if (use-region-p)                  ; IF
;;     (progn                            ; THEN
;;       (delete-region (region-beginning) (region-end))
;;       (my/fix-space)) 
;; (progn ; ELSE 
;;     (delete-backward-char 1)
;; (when (or (looking-back "^[[:space:]]+") 
;; (looking-at "[[:punct:]]"))
;; (delete-horizontal-space)) 
;; ))) 
;; 
;; ;; delete backward one char unless the region is active: 
;; (defun my/delete-backward ()
;; "When there is an active region, delete it and then fix up the whitespace"
;;   (interactive)
;;   (if (use-region-p)                  ; IF
;;     (progn                            ; THEN
;;       (delete-region (region-beginning) (region-end))
;;       (my/fix-space)) 
;; (progn ; ELSE 
;;     (delete-backward-char 1)
;; ))) 

;;; new version
;; delete backward one char unless the region is active: 
(defun my/delete-backward ()
  "When there is an active region, delete it and then fix up the whitespace"
  (interactive)
  (if (use-region-p)
      (delete-region (region-beginning) (region-end))
    (delete-backward-char 1))
  (save-excursion
    (when (or (looking-at "[[:space:]]")
              (looking-back "[[:space:]]"))
      (my/fix-space))))
#+END_SRC
*** TODO [#B] enable my-delete-backward to delete region and capitalize new first letter in sentence 
Rúdi: Can we add to my/delete-backward something like what I wrote below, so that if I delete a region containing the first part of a sentence or sentences, it automatically capitalizes the first letter of what is now the first word in the sentence?

#+BEGIN_QUOTE
First delete region, and then: 
(if (my/beginning-of-sentence-p)
(progn
(capitalize-word)
 (left-word)
))) 
#+END_QUOTE 

** timesvr

#+BEGIN_SRC emacs-lisp 
(defun timesvr ()
  "Task request to my virtual assistant."
  (interactive)
  (message-mail)
  (message-goto-subject) (insert "task request: " (format-time-string "%F %l:%M%P"))
  (message-goto-body) (insert "\n")
  )
(global-set-key (kbd "C-c t") 'timesvr)
(global-set-key (kbd "C-c m") 'compose-mail)
#+END_SRC

* Startup

#+BEGIN_SRC emacs-lisp
;; (toggle-maxframe)
;; (monaco-font)
(zenburn)
(recenter-top-bottom)
#+END_SRC

* character movement
#+BEGIN_SRC emacs-lisp

(defun jay/left-char ()
  "Move point to the left or the beginning of the region.
 Like `backward-char', but moves point to the beginning of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'left-char)) ;; maintain compatibility
    (let ((left (min (point)
                     ;; `mark' returning nil is ok; we'll only use this
                     ;; if `mark-active'
                     (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn
            (goto-char left)
            (setq deactivate-mark t))
        (call-interactively 'left-char)))))


(defun jay/right-char ()
  "Move point to the right or the end of the region.
 Like `right-char', but moves point to the end of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'right-char)) ;; maintain compatibility
    (let ((right (max (point)
                      ;; `mark' returning nil is ok; we'll only use this
                      ;; if `mark-active'
                      (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn (goto-char right)
		 (setq deactivate-mark t))
	(call-interactively 'right-char)))))

(define-key org-mode-map (kbd "<left>") 'jay/left-char)
(define-key org-mode-map (kbd "<right>") 'jay/right-char)

#+END_SRC


* experiments - tested
#+BEGIN_SRC emacs-lisp
(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)
 
(define-key org-mode-map (kbd"<SPC>") 'jay/insert-space)

(defun reflash-indentation ()
"One sentence summary of what this command do."
  (interactive)
  (org-indent-mode 1)
  ) 
#+END_SRC
* experiments - new/untested
** source code blocks
[[http://wenshanren.org/?p%3D334][Emacs：insert source code block in org-mode | 肉山博客 (Wenshan's Blog)]]


#+BEGIN_SRC emacs-lisp
(defun org-insert-src-block (src-code-type)
  "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
  (interactive
   (let ((src-code-types
          '("emacs-lisp" "css"
"dot"

"latex")))
     (list (ido-completing-read "Source code type: " src-code-types))))
  (progn
    (newline-and-indent)
    (insert (format "#+BEGIN_SRC %s\n" src-code-type))
    (newline-and-indent)
    (insert "#+END_SRC\n")
    (previous-line 2)
    (org-edit-src-code)))

(local-set-key (kbd "C-c v e")
               'org-edit-src-code)
;; keybinding for inserting code blocks
(local-set-key (kbd "C-c v i")
               'org-insert-src-block) 
#+END_SRC

** hunspell 

   #+BEGIN_SRC emacs-lisp

(when (executable-find "hunspell")
  (setq-default ispell-program-name "hunspell")
  (setq ispell-really-hunspell t)) 
(setq flyspell-default-dictionary "en_US")

(setq ispell-dictionary "en_US")
(setq ispell-program-name "/usr/local/bin/hunspell") 
(setenv "DICTIONARY" "en_US") 
(if (file-exists-p "/usr/bin/hunspell")
    (progn
      (setq ispell-program-name "hunspell")
      (eval-after-load "ispell"
        '(progn (defun ispell-get-coding-system () 'utf-8))))) 

(executable-find "hunspell")
;;  (setq ispell-program-name "hunspell")
;;(setq ispell-local-dictionary-alist '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil nil nil utf-8))) (setq ispell-extra-args '("-d en_US") 
(flyspell-mode-on) 
   #+END_SRC

References:
[[http://emacswiki.org/emacs/InteractiveSpell#toc2][EmacsWiki: Interactive Spell]]
[[https://lists.gnu.org/archive/html/help-gnu-emacs/2015-03/msg00153.html][Getting flyspell + hunspell to work on OS X 10.10]]
[[https://joelkuiper.eu/spellcheck_emacs][Spell checking in Emacs]]
[[http://stackoverflow.com/questions/25415070/hunspell-emacs-on-os-x-10-9][hunspell / emacs on OS X 10.9 - Stack Overflow]]
[[http://stackoverflow.com/questions/3961119/working-setup-for-hunspell-in-emacs][Working setup for hunspell in Emacs - Stack Overflow]]
[[http://unix.stackexchange.com/questions/86554/make-hunspell-work-with-emacs-and-german-language][spell checking - Make hunspell work with emacs and german language - Unix & Linux Stack Exchange]]
[[http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html][What's the best spell check setup in emacs | Chen's blog]]
[[http://www.lonecpluspluscoder.com/2015/03/setting-up-emacs-spell-checking-on-os-x/][Setting up Emacs spell checking on OS X - The Lone C++ Coder's Blog]]
 

* Helm Org Wiki

I'm using an extremely simplistic approach: just dump all the org
files into one directory.  The name of each org file should be concise
but descriptive, e.g. Makefile.org describes Makefiles, and git.org
describes git.

This simplicity completely alleviates organization effort: there's
nothing to organize, since there's only one directory to put the files in.
At the same time, it's very accessible by means of two `helm` wrappers:

- globally, "C-0" runs the command helm-org-wiki (the code is below)
- in org-mode, "g" runs the command wspecial-worf-goto (the code is at
https://github.com/abo-abo/worf)

It's like a two-stage personal Google: the first stage is to find an org-file,
the second stage is to search within an org-file.

For example, here's the sequence of key bindings when I want to look
up how git bisect works, assuming that I'm in some random buffer, like
`ansi-term`:

        C-0 gi RET g bis RET

Done. Note that "gi" was enough to match "git.org", since all my other
pages don't contain "gi".  Same thing for "bis" being able to match
uniquely the heading "git bisect".  I think that it's quite optimal
that I'm able to find the topic "git bisect" by using only 10 key
presses, which is the same as the amount of characters in "git
bisect".  Compare this to `helm-google-suggest` (bound to "C-p g"):

        C-p g git bi RET TAB RET

That's 12 key presses (10 in Emacs, 2 in Firefox).

New wiki pages can be created with "C-0" as well, just type in the
name of the new file and hit RET.

That's it, the code is below. It's very similar to `org-switchb`,
except that the files need not be opened to appear in the completion
list, and new files are created if there's no match.

regards,
Oleh
(Source: http://lists.gnu.org/archive/html/emacs-orgmode/2014-04/msg01134.html) 

#+BEGIN_SRC emacs-lisp 
    (defgroup helm-org-wiki nil
      "Simple jump-to-org-file package."
      :group 'org
      :prefix "helm-org-wiki-")
    (defcustom helm-org-wiki-directory "~/nd/"
      "Directory where files for `helm-org-wiki' are stored."
      :group 'helm-org-wiki
      :type 'directory)
    (defun helm-org-wiki-files ()
      "Return .org files in `helm-org-wiki-directory'."
      (let ((default-directory helm-org-wiki-directory))
        (mapcar #'file-name-sans-extension
                (file-expand-wildcards "*.txt"))))
    (defvar helm-source-org-wiki
      `((name . "Projects")
        (candidates . helm-org-wiki-files)
        (action . ,(lambda (x)
                      (find-file (expand-file-name
                                  (format "%s.txt" x)
                                  helm-org-wiki-directory))))))
    (defvar helm-source-org-wiki-not-found
      `((name . "Create org-wiki")
        (dummy)
        (action . (lambda (x)
                    (helm-switch-to-buffer
                     (find-file
                      (format "%s/%s.org"
                              helm-org-wiki-directory x)))))))
    ;;;###autoload
    (defun helm-org-wiki ()
      "Select an org-file to jump to."
      (interactive)
      (helm :sources
            '(helm-source-org-wiki
              helm-source-org-wiki-not-found)))
    (provide 'helm-org-wiki)

#+END_SRC


* Emacs Lisp Mode
#+BEGIN_SRC emacs-lisp 
(defun turn-on-autocomplete-mode ()
   (auto-complete-mode 1))
(add-hook 'emacs-lisp-mode-hook 'turn-on-autocomplete-mode )
#+END_SRC
 
* Reference for cleaning up whitespace around sentences:
[[http://stackoverflow.com/questions/4754547/redefining-sentence-in-emacs-single-space-between-sentences-but-ignoring-ab][regex - Redefining "sentence" in Emacs? (single space between sentences, but ignoring abbreviations) - Stack Overflow]]

* cycle-hyphenation 

#+BEGIN_SRC emacs-lisp
(defun cycle-hyphenation ()
  (interactive)
  (cond ((re-search-forward "\\=\\W*\\w+\\(-\\)\\w+" nil t)
         (save-excursion (replace-match " " t t nil 1)))
        ((re-search-forward "\\=\\W*\\w+\\( +\\)\\w+" nil t)
         (save-excursion (replace-match "-" t t nil 1)))))
#+END_SRC

* clone subtree 
#+BEGIN_SRC emacs-lisp
(defun org-clone-subtree ()
  (interactive)
  (org-clone-subtree-with-time-shift 1)
  (save-excursion
    (org-goto-sibling)
    ;; This part was lifted partly and adapted from
    ;; http://orgmode.org/worg/org-hacks.html#orgheadline10.
    ;; There should be a better way to change the contents of an org heading
    ;; though...
    (when (org-at-heading-p)
      (let ((hl-text (nth 4 (org-heading-components)))
            (buffer-undo-list))
        (when hl-text
          (beginning-of-line)
          (search-forward hl-text (point-at-eol))
          (replace-match (format "%s - clone" hl-text) nil t)
          (org-align-tags-here org-tags-column))))))
#+END_SRC



** smart-punctuation (auxiliary)

#+BEGIN_SRC emacs-lisp 
(defvar *smart-punctuation-marks*
  ".,;:!?-")

(setq *smart-punctuation-exceptions*
  (list "?!" ".." "..." "---"))

(defun smart-punctuation (new-punct &optional not-so-smart)
  (expand-abbrev)
  (let ((old-point (point)))
    ;; 1. go back until there are no more spaces/tabs
    (when (re-search-backward "[^ 	][ 	]+\\="
                              nil t)
      (forward-char 1))
    (flet ((replace (text)
             (let ((nr-new-chars (- (length text) (length (match-string 1)))))
               (replace-match text t t nil 1)
               (goto-char old-point)
               (forward-char nr-new-chars))))
      (let (exception)
        (cond ((or not-so-smart
                   (not (re-search-backward (format "[^%s]\\([%s]+\\)\\="
                                                    *smart-punctuation-marks*
                                                    *smart-punctuation-marks*)
                                            nil t)))
               ;; 2.1. if there's not a series of punctuation marks, or if we
               ;; don't want to replace (`not-so-smart'), just insert the
               ;; `new-punct', and move to the `old-point' + the length of
               ;; `new-punct'.
               (insert new-punct)
               (goto-char old-point)
               (forward-char (length new-punct)))
              ((setf exception
                     (let ((potential-new-punct
                            (concat (match-string 1) new-punct)))
                       (find-if (lambda (exception)
                                  (search potential-new-punct exception))
                                *smart-punctuation-exceptions*)))
               ;; 2.2. if the series of punctuation marks concatenated with
               ;; `new-punct' form (even if partially) an exception, then replace
               ;; it with that exception and fix the spaces.
               (replace exception))
              (t
               ;; 2.3. if there is a series of punctuation marks and there is no
               ;; matching exception, replace by the `new-punct' and fix the
               ;; spaces.
               (replace new-punct)))))))
#+END_SRC

** smart-period
#+BEGIN_SRC emacs-lisp 
(defun smart-period ()
  (interactive)
  (smart-punctuation "."))

(define-key org-mode-map (kbd ".") 'smart-period)
#+END_SRC

** smart-comma
#+BEGIN_SRC emacs-lisp 
(defun smart-comma ()
  (interactive)
  (smart-punctuation ","))

(define-key org-mode-map (kbd ",") 'smart-comma)
#+END_SRC

** smart-question-mark
#+BEGIN_SRC emacs-lisp 
(defun smart-question-mark ()
  (interactive)
  (smart-punctuation "?"))

(define-key org-mode-map (kbd "?") 'smart-question-mark)
#+END_SRC

** smart-exclamation-point
#+BEGIN_SRC emacs-lisp 
(defun smart-exclamation-point ()
  (interactive)
  (smart-punctuation "!"))

(define-key org-mode-map (kbd "!") 'smart-exclamation-point)
#+END_SRC

** smart-hyphen
(defun smart-hyphen ()
  (interactive)
  (smart-punctuation "-"))

(define-key org-mode-map (kbd "-") 'smart-hyphen)
#+END_SRC

** smart-semicolon

#+BEGIN_SRC emacs-lisp 
(defun smart-semicolon ()
  (interactive)
  (smart-punctuation ";" t))

(define-key org-mode-map (kbd ";") 'smart-semicolon)
#+END_SRC

** smart-colon

#+BEGIN_SRC emacs-lisp 
(defun smart-colon ()
  (interactive)
  (smart-punctuation ":" t))

(define-key org-mode-map (kbd ":") 'smart-colon)
#+END_SRC


* TODO [#C] cycle punctuation                                          :rudi:

create a function cycle-punctuation. Kind of like cycle-hyphenation, except that invoking cycle-punctuation would change the punctuation at the end of a sentence between "." "!" "?" and back again. Such that given the sentence...

: The rain in Spain falls mainly on the plains. 

...and assuming the point was on the "T" or the "." or anywhere in between, invoking cycle-punctuation would leave the point wherever it was and cycle between these three states:

: The rain in Spain falls mainly on the plains. 
: The rain in Spain falls mainly on the plains? 
: The rain in Spain falls mainly on the plains! 

In fact, let's create a cycle-punctuation function also, even if the smart-punctuation functions above are also feasible. Here's some code that might help. 
http://ergoemacs.org/emacs/elisp_change_space-hyphen_underscore.html 

Thanks!!

(define-key org-mode-map (kbd "M-.") 'cycle-punctuation)


** TODO [#C] request: backspace after expand-abbrev 
Hi Rúdi,

To complete the cycle on all these enchancesments to how Emacs handles spacing and abbrev expansion, I want to create a better way to correct typos. 

The problem is that if I make a typographical error when I'm typing an abbrev, it becomes difficult to correct it. 

See below. 

<KB>bc </KB> 
output: 
#+BEGIN_EXAMPLE: 
because ^
#+END_EXAMPLE:

<KB>bg </KB> 
output: 
#+BEGIN_EXAMPLE: 
beginning ^
#+END_EXAMPLE:

Let's say I accidentally type "bg" when I meant to type "bc". Now I'm at the end of the word beginning. If I hit BACKSPACE (my/delete-backward) I now have to delete through an entire unwanted word.

Is it possible (and not too difficult) to make it so that if I invoke my/delete-backward within a few keystrokes of Emacs running expand-abbrev, to run unexpand-abbrev automatically? Thanks! 

** TODO [#B] self insert space                                        :rudi:
Can we create a command to self-insert space? Which I'll bind to M-SPC in case I ever need to insert a space the old-fashioned way without invoking all this fancy DWIM stuff. Thanks. :-)

** TODO [#A] make kill-word-correctly-and-capitalize count a line break as a word 
Rúdi, 

Before I asked you to make kill-word-correctly kill not only words one at a time, but also punctuation one at a time, such that given this... 

#+BEGIN_QUOTE
The sea. Ocean. 

I still remember that day.
#+END_QUOTE 

...and supposing the mark was on the T in The, invoking kill-word-correctly twice would kill "The" and "sea" but leave in period, and invoking it a third time would kind the period as well. And you implemented this perfectly. 

Now I’d like to make kill-word-correctly and kill-word-correctly-and-capitalize recognize line breaks in the same way, counting each line break as a word. 

In the above, let's say the point is on the "O" in "Ocean". And let's say I invoke kill-word-correctly-and-capitalize 3 times. 

Current output: 

#+BEGIN_QUOTE
The sea. still remember that day.
#+END_QUOTE 

Desired output: 

#+BEGIN_QUOTE
The sea. 
I still remember that day.
#+END_QUOTE 

Thanks!

** TODO [#A] an edge case for kill-word-correctly-and-capitalize

#+BEGIN_QUOTE
He's a science writer specializing in psychology (NYT, Wired, Psychology Today). 
#+END_QUOTE

Suppose the point is on the "is" in "specializing" and my goal is to invoke kill-word-correctly-and-capitalize 3 times in order to kill the phrase "specializing in psychology".

Current output: 
He's a science writer(NYT, Wired, Psychology Today). 

Desired output: 
He's a science writer specializing in psychology (NYT, Wired, Psychology Today). 

Note that the same output is created if I highlight the phrase "specializing in psychology" and hit my/delete-backward.

Can we fix for both kill-word-correctly-and-capitalize and my/delete-backward? Thanks!

*** TODO Try it now

    The problem was with ~my/fix-space~, which was deleting spaces before punctuation indiscriminately. Now it only deletes spaces before the characters: .,:;!?»)-. Note that this will affect many other functions, sice ~my/fix-space~ is called in a number of places. I think the result will nonetheless be the desired one.
