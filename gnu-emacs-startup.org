* file settings                                                     :ARCHIVE:
#+OPTIONS: f:t 
#+TODO: TODO PLEASE-TEST TESTING PLEASE-DEBUG | DONE 
#+TODO: | NOTE-TO-JAY NOTE-TO-RUDI NOTE-TO-RÚDI 
#+TITLE: #+TITLE: Jay Dixit's GNU Emacs setup 
#+TITLE: Jay Dixit's GNU Emacs setup
* About
  - System: Mac OSX Yosemite
  - Emacs version: 24.5.1
  - Use case: GNU Emacs specific settings.

* Handle Emacs UTF-8 input

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setenv "LANG" "en_US.UTF-8")
#+END_SRC

* Sticky windows

#+BEGIN_SRC emacs-lisp
(global-set-key [(control x) (?0)] 'delete-other-windows)
(global-set-key [(control x) (?9)] 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-0") 'delete-window)
(global-set-key  (kbd "s-1") 'delete-other-windows)
(global-set-key  (kbd "s-9") 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-2") 'split-window-vertically)
(global-set-key  (kbd "s-3") 'split-window-horizontally)
#+END_SRC

* Abbreviations (autocorrect)

Automatically load abbreviations table:
#+BEGIN_SRC emacs-lisp
(setq-default abbrev-mode t)
(read-abbrev-file "~/Dropbox/elisp/.abbrev_defs") 
(set (make-local-variable 'abbrev-file-name) (expand-file-name "~/Dropbox/elisp/own-abbrevs.abbrev_defs")) 
(read-abbrev-file "~/Dropbox/elisp/own-abbrevs.abbrev_defs")
(setq save-abbrevs t)
(setq only-global-abbrevs t)
#+END_SRC

* UI/Appearance

Clean UI:
#+BEGIN_SRC emacs-lisp
(tooltip-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode 1)
#+END_SRC

Don't highlight lines:
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
          (lambda()
            (hl-line-mode -1)
            (global-hl-line-mode -1))
          't
          )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq prelude-whitespace nil)
#+END_SRC

Wrap text:
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode)
#+END_SRC

* Fullscreen settings

[[http://amitp.blogspot.ca/2008/05/emacs-full-screen-on-mac-os-x.html][(Source)]]

#+BEGIN_SRC emacs-lisp
(defvar maxframe-maximized-p nil "maxframe is in fullscreen mode")

(defun toggle-maxframe ()
  "Toggle maximized frame"
  (interactive)
  (setq maxframe-maximized-p (not maxframe-maximized-p))
  (cond (maxframe-maximized-p (maximize-frame))
        (t (restore-frame))))

(define-key global-map [(s-return)] 'toggle-maxframe)
;; make it easy to go fullscreen
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

;; and the keybinding 
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f11>") 'toggle-fullscreen))
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f13>") 'toggle-fullscreen))

  (global-set-key (kbd "<f13>") 'toggle-fullscreen)

#+END_SRC

* Directory settings

There is probably a lot of redundancy here, I don't understand this stuff too
well.

#+BEGIN_SRC emacs-lisp
(defun mydired-sort ()
  "Sort dired listings with directories first."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
    (set-buffer-modified-p nil)))

(defadvice dired-readin
  (after dired-after-updating-hook first () activate)
  "Sort dired listings with directories first before adding marks."
  (mydired-sort)
  (let ((dired-details-internal-overlay-list  ())) (dired-details-hide)))

(add-hook 'dired-load-hook
	  (lambda ()
(require 'dired-sort-menu)))


(defcustom dired-details-hidden-string ""
  "*This string will be shown in place of file details and symbolic links."
  :group 'dired-details
  :type 'string)

(defcustom dired-details-initially-hide t
  "*Hide dired details on entry to dired buffers."
  :group 'dired-details
  :type 'boolean)
#+END_SRC

 omit certain specific uninteresting file types from dired
#+BEGIN_SRC emacs-lisp

(require 'dired-x)
(setq-default dired-omit-files-p t) ; this is buffer-local variable


;; (setq dired-omit-files "^\\.[^.]\\|\\.pdf$\\|\\.tex$\\|\\.DS_Store\\|\\.doc$\\|\\.docx$\\|\\.xlsx$\\|\\.ini$\\|\\.fsLockFile$\\|Icon*")

(setq dired-omit-files "^\\.[^.]\\|\\.pdf$\\|\\.tex$\\|\\.DS_Store$\\|\\.doc$\\|\\.docx$\\|\\.ini$\\|\\.rtf$\\|\\Icon*\\|\\*html")

;; Enable toggling of uninteresting files.
(setq dired-omit-mode t)
(setq-default dired-omit-files-p t) ; this is buffer-local variable

(defun enable-dired-omit-mode () (dired-omit-mode 1))
(add-hook 'dired-mode-hook 'enable-dired-omit-mode)


;; Load Dired X when Dired is loaded.
(add-hook 'dired-load-hook '(lambda () (require 'dired-x)))

;; so that I can hide details on dired
(require 'dired-details+)
#+END_SRC

* Other functions

Manually remove the scrollbar if default setting fails when creating a new frame:

#+BEGIN_SRC emacs-lisp
(defun scrollbar-init ()
  (interactive)
  (scroll-bar-mode -1)
  )
#+END_SRC


Forgot what this does, I think it's in case Emacs crashes maybe to recover
autosaves?
#+BEGIN_SRC emacs-lisp
(defadvice recover-session (around disable-dired-omit-for-recover activate)
  (let ((dired-mode-hook dired-mode-hook))
    (remove-hook 'dired-mode-hook 'enable-dired-omit-mode)
    ad-do-it))
#+END_SRC

* Isolate Emacs kill ring from the OSX system pasteboard (clipboard).

Very important, I use this all the time.  These are custom functions to separate
the OSX clipboard from Emacs' kill ring, effectively giving me two separate
clipboards to work from. The below are the traditional OSX keybindings for
cut/copy/paste, and they will now work with the OSX clipboard. The yank and pop functions still work, and use the Emacs kill ring instead.


** Setup
#+BEGIN_SRC emacs-lisp
(setq interprogram-cut-function nil)
(setq interprogram-paste-function nil)
#+END_SRC
 
** pasteboard-copy
#+BEGIN_SRC emacs-lisp

(defun pasteboard-copy()
  "Copy region to OS X system pasteboard."
  (interactive)
  (shell-command-on-region
   (region-beginning) (region-end) "pbcopy"))
#+END_SRC

** pasteboard-paste

#+BEGIN_SRC emacs-lisp 
;;; old version; remove after testing new one (see below)
;; (defun pasteboard-paste()
;;   "Paste from OS X system pasteboard via `pbpaste' to point."
;;   (interactive)
;; (my/fix-space)
;;   (shell-command-on-region
;;    (point) (if mark-active (mark) (point)) "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'" nil t)
;; (my/fix-space)
;; ;; (when (looking-back "^[[:space:]]+") (just-one-space)) ; this didn't work
;; )

;;; new version; not thoroughly tested
(defun pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
        (end (if mark-active
                 (mark)
               (point))))
    (shell-command-on-region start end
                             "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
                             nil t)
    (my/fix-space)
    (save-excursion
      (goto-char start)
      (my/fix-space))))
#+END_SRC

** minibuffer-pasteboard-paste

#+BEGIN_SRC emacs-lisp 
(defun minibuffer-pasteboard-paste ()
  "Paste from OS X system pasteboard via `pbpaste' to point."
  (interactive)
  (let ((start (point))
	(end (if mark-active
		 (mark)
	       (point))))
    (shell-command-on-region start end
			     "pbpaste | perl -p -e 's/\r$//' | tr '\r' '\n'"
			     nil t) 
    (save-excursion

      )))
#+END_SRC

** pasteboard-cut

#+BEGIN_SRC emacs-lisp 
(defun pasteboard-cut()
  "Cut region and put on OS X system pasteboard."
  (interactive)
  (pasteboard-copy)
  (delete-region (region-beginning) (region-end))
(my/fix-space)
)
#+END_SRC
* Searching
** pasteboard-search-in-current buffer 
#+BEGIN_SRC emacs-lisp
(defun pasteboard-search-in-current-buffer ()
  (interactive)
  (let ((search-term
         (with-temp-buffer
           (pasteboard-paste)
           (buffer-string))))
    (search-forward search-term)))

#+END_SRC

* Keybindings

** Create custom keybinding prefix 

#+BEGIN_QUOTE
I have an unconventional approach to this that I recommend highly. I have redefined the C-l ('ell') key to be a prefix key, and I use that to prefix my favorite commands. This key is very easy to type and it is bound to a function ('recenter) that isn't used that much. Well, I don't use 'recenter much, but even if you did, it can be assigned to C-l C-l which is almost as easy to type, and a small price to pay for the possibilities opened up by the Ctrl-L-map. (Actually I prefer 'redraw-display to 'recenter, so I gave that the place of honor.)
#+END_QUOTE
Source: [[http://stackoverflow.com/questions/5682631/what-are-good-custom-keybindings-in-emacs/5682737#5682737][ LenW's answer on keyboard - What are good custom keybindings in emacs? - Stack Overflow]]

Use ⌘-m as prefix for my own custom keybindings:
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "s-m"))
(defvar s-m-map (make-keymap)
  "Keymap for local bindings and functions, prefixed by (Command-M)")
(define-key global-map (kbd "s-m") 's-m-prefix)
(fset 's-m-prefix s-m-map)
#+END_SRC

** Custom keybindings

#+BEGIN_SRC emacs-lisp
;; create a custom minor mode to override other keybindings and use mine instead
(defvar key-minor-mode-map (make-keymap) "key-minor-mode keymap.")
(define-minor-mode key-minor-mode
  "A minor mode so that my key settings override annoying major modes."
  t " key" 'key-minor-mode-map)
(key-minor-mode 1)
(defun my-minibuffer-setup-hook ()
  (key-minor-mode 0))
(add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)

;; unbind some existing keybindings 
(define-key undo-tree-map (kbd "C-x r") nil)

;; and the keybindings
;; mk - mykeybindings

(define-key key-minor-mode-map (kbd "<s-return>") 'toggle-fullscreen) 

(define-key key-minor-mode-map (kbd "s-v") 'pasteboard-paste)
(define-key key-minor-mode-map (kbd "s-x") 'pasteboard-cut)
(define-key key-minor-mode-map (kbd "s-c") 'pasteboard-copy)

(define-key minibuffer-local-map (kbd "s-v") 'minibuffer-pasteboard-paste)

(define-key key-minor-mode-map (kbd "s-F") 'pasteboard-search-in-current-buffer) 


(define-key key-minor-mode-map (kbd "s-Z") 'unexpand-abbrev)

(global-unset-key (kbd "C-S-r")) 
(define-key key-minor-mode-map (kbd "C-S-r") nil)
(define-key org-mode-map (kbd "C-S-r") nil)


(define-key key-minor-mode-map (kbd "s-N") 'ni-narrow-to-region-indirect-other-window)



;; pop mark
(define-key key-minor-mode-map (kbd "C-x p")'pop-to-mark-command)

;; projectile
(define-key key-minor-mode-map (kbd "s-P") 'projectile-commander)

;; and make it work in the minibuffer too
(define-key minibuffer-local-map (kbd "s-v") 'pasteboard-paste)
(define-key minibuffer-local-map (kbd "s-x") 'pasteboard-cut)
(define-key minibuffer-local-map (kbd "s-c") 'pasteboard-copy)

(define-key key-minor-mode-map (kbd "C-c C-v") 'refile-region)
(define-key key-minor-mode-map (kbd "H-w") 'widen)
(define-key key-minor-mode-map (kbd "C-c e") 'eval-buffer)
(define-key key-minor-mode-map (kbd "C-c r") 'eval-region)
(define-key key-minor-mode-map (kbd "C--") 'goto-last-change) ; super useful when editing
(define-key key-minor-mode-map (kbd "C-d") 'kill-word-correctly-and-capitalize)
(define-key key-minor-mode-map (kbd "C-j") 'prelude-top-join-line)


(define-key key-minor-mode-map (kbd "C-S-l") 'reflash-indentation)
(define-key key-minor-mode-map (kbd "C-l") 'recenter-top-bottom)


(define-key key-minor-mode-map (kbd "=") 'smex) ; call any function with easiest keystroke possible
(define-key key-minor-mode-map (kbd "M-x") 'helm-M-x) ; call helm-M-x instead of regular M-as
;; (define-key key-minor-mode-map (kbd "\|") 'deft)

(define-key key-minor-mode-map (kbd "M-K") 'kill-clause)

(define-key key-minor-mode-map (kbd "M-8") 'org-toggle-heading)

(define-key key-minor-mode-map (kbd "C-t") 'transpose-words)

(define-key key-minor-mode-map (kbd "M--") 'cycle-hyphenation)

(define-key key-minor-mode-map (kbd "C-c j") 'helm-org-headlines) ; also bound to keychord jj
(define-key key-minor-mode-map (kbd "C-x b") 'helm-mini) ; shows recent files; also bound to ⌘-r 
(define-key key-minor-mode-map (kbd "M-b M-d") 'book-dired) ; show directory of my book folder
(define-key key-minor-mode-map (kbd "M-b r") 'read-a-book) ; show directory of my PDF books 
(define-key key-minor-mode-map (kbd "M-b j") 'read-jd) ; show PDF books I have annotated
(define-key key-minor-mode-map (kbd "M-b M-b") 'work-on-book) ; 

(define-key key-minor-mode-map (kbd "M-b M-w") 'work-on-book) ; 

;; book bindings
(define-key key-minor-mode-map (kbd "M-b M-p") 'book-proposal-directory) ; go to my book folder
(define-key key-minor-mode-map (kbd "M-b M-r") 'book-helm-strict) ; this is a smart function, show recent files in my book folder

;; can't get this to work. for some reason GNU Emacs interprets ⌘-shift-d as s-c
(define-key key-minor-mode-map (kbd "s-D") 'diredp-dired-recent-dirs) 

;; recent directories... but how to populate it?
(define-key key-minor-mode-map (kbd "C-S-d") 'diredp-dired-recent-dirs) 

;; own structure editing
(define-key key-minor-mode-map (kbd "C-c C-`") 'move-region-to-other-window) ; very useful when working with a split frame

;; (define-key key-minor-mode-map (kbd "C-c C-w") 'org-refile) ; very useful when working with a split frame

;; for extracting content from my browser
(define-key key-minor-mode-map (kbd "s-W") 'web-research)
(define-key key-minor-mode-map (kbd "s-I") 'web-research-quotes)
(define-key key-minor-mode-map (kbd "s-V") 'kdm/html2org-clipboard) ; paste HTML content that I've copied from the web, automatically converting to proper org-mode syntax


;; and the keybinding
(define-key org-mode-map (kbd "C-k") 'my/kill-line-dwim)


;; use OSX standard keybindings ⌘-up and ⌘-down to go to top or bottom of buffer
(define-key key-minor-mode-map [s-up] 'beginning-of-buffer)
(define-key key-minor-mode-map [s-down] 'end-of-buffer)

;; use OSX standard keybinding for "Redo"
(define-key key-minor-mode-map (kbd "s-y") 'undo-tree-redo)

;; use OSX standard keybinding to increase or decrease font size 
(define-key key-minor-mode-map (kbd "s-=") 'text-scale-increase)
(define-key key-minor-mode-map (kbd "s--") 'text-scale-decrease)

;; rebind global help command so that I can use C-h for backspace
(define-key key-minor-mode-map (kbd "M-h") 'help-command)

;; very useful when encountering names and other unfamiliar words
(define-key key-minor-mode-map (kbd "M-+") 'add-word-to-personal-dictionary)

;; navigate between buffers, including uninteresting ones that are hidden by default
(define-key key-minor-mode-map (kbd "M-s-<right>") 'switch-to-next-buffer)
(define-key key-minor-mode-map (kbd "M-s-<left>") 'previous-buffer)

;; deleting things
(define-key key-minor-mode-map (kbd "<backspace>") 'my/delete-backward)

;; a keybinding for "delete" in addition to "backspace"
(define-key key-minor-mode-map (kbd "C-<backspace>") 'delete-char)
(define-key key-minor-mode-map (kbd "M-<backspace>") 'backward-kill-word-correctly)
 
;; pomodoro
(define-key key-minor-mode-map (kbd "C-c C-x pi") 'pomodoro-start)
(define-key key-minor-mode-map (kbd "C-c C-x po") 'pomodoro-stop)

;; find files using helm
(define-key key-minor-mode-map (kbd "C-x C-f") 'helm-find-files) 

;; search using helm-swoop
(global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
(global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
(global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)
(global-set-key (kbd "M-i") 'helm-multi-swoop-all)

;; edit Emacs preferences using standard OSX keybinding for preferences
(define-key key-minor-mode-map (kbd "s-,") 'customize-group)

;; grep, using current folder as default
(define-key key-minor-mode-map (kbd "s-G") 'helm-do-grep)

;; some custom functions
(define-key key-minor-mode-map (kbd "C-c C-m") 'move-region-to-other-window)
#+END_SRC

** keybindings not currently in use 
 (define-key key-minor-mode-map (kbd "DEL")  'new-org-delete-backward-char)
 (global-set-key (kbd "C-c s") 'org-copy-subtree)
 (define-key key-minor-mode-map (kbd "C-v s") 'org-paste-subtree)
 (define-key key-minor-mode-map (kbd "s-l") 'org-insert-link)
 (define-key key-minor-mode-map (kbd "s-i") 'markdown-insert-image)
 (define-key key-minor-mode-map (kbd "s-\\") 'org-ctrl-c-ctrl-c)
 (define-key key-minor-mode-map (kbd "s-u") 'ido-dired)
 (define-key key-minor-mode-map (kbd "H-n") 'org-narrow-to-subtree)
 (define-key key-minor-mode-map (kbd "H-w") 'widen)
 (define-key key-minor-mode-map (kbd "H-G") 'prelude-google)
 (define-key key-minor-mode-map (kbd "s-G") 'osx-browse-guess)
 (define-key key-minor-mode-map (kbd "s-L") 'org-mac-chrome-insert-frontmost-url)
 (define-key key-minor-mode-map (kbd "s-") 'google-define-word-or-phrase)
 (define-key key-minor-mode-map (kbd "C-c C-x C-o") 'org-pomodoro)
 (define-key key-minor-mode-map (kbd "s-R") 'web-research)
 (define-key key-minor-mode-map (kbd "s-v") 'clipboard-yank) 


;; (define-key key-minor-mode-map (kbd "<right>") 'aquamacs-right-char)
;; (define-key key-minor-mode-map (kbd "<right>") 'switch-to-next-buffer)
;; (define-key key-minor-mode-map (kbd "<right>") 'switch-to-next-buffer)
;; (define-key key-minor-mode-map (kbd "<down>") 'aquamacs-next-line)




* Sentences

Make ~kill-sentence~ work in a more intuitive way:
#+BEGIN_SRC emacs-lisp
(defun kill-sentence-to-period ()
  "Leave the period in there."
  (interactive)
  (kill-sentence)
  (push-mark)
  (insert ".")
  (backward-char)
)
#+END_SRC

[[http://emacs.stackexchange.com/questions/12266/how-change-behavior-of-kill-sentence-based-on-position-in-sentence/12321?iemail=1&noredirect=1#12321][Source]]

#+BEGIN_SRC emacs-lisp
(defun my/forward-to-sentence-end ()
  "Move point to just before the end of the current sentence."
  (forward-sentence)
  (backward-char)
  (unless (looking-back "[[:alnum:]]")
    (backward-char)))

(defun my/beginning-of-sentence-p ()
  "Return  t if point is at the beginning of a sentence."
  (let ((start (point))
        (beg (save-excursion (forward-sentence) (forward-sentence -1))))
    (eq start beg)))

(defun my/kill-sentence-dwim ()
  "Kill the current sentence up to and possibly including the punctuation.
When point is at the beginning of a sentence, kill the entire
sentence. Otherwise kill forward but preserve any punctuation at the sentence end."
  (interactive)
(expand-abbrev)
  (if (my/beginning-of-sentence-p)
      (progn
        (kill-sentence)
        (just-one-space)
        (when (looking-back "^[[:space:]]+") (delete-horizontal-space)))
      (kill-region (point) (progn (my/forward-to-sentence-end) (point)))
      (just-one-space 0))
(when (looking-at ".. ")
(delete-forward-char 1)) 
)

;; and the keybinding
(global-set-key (kbd "M-k") 'my/kill-sentence-dwim)

(defun my/kill-line-dwim ()
  "Kill the current line."
  (interactive)
(expand-abbrev)
(org-kill-line)
(my/fix-space))
#+END_SRC

* Browsing

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
#+END_SRC

* Pastebin

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/gnulisp/emacs-pastebin-master/")
(require 'neopastebin)
(pastebin-create-login :dev-key "e5ccb53890f16065d90ebd6064a381d0"
                       :username "petersalazar")
#+END_SRC

* Custom functions

;;; old version; remove after testing new one
;; (defun my/fix-space ()
;; "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
;; (interactive)
;; (just-one-space)
;; (when (or (looking-back "^[[:space:]]+") 
;; (looking-at "[[:punct:]]"))
;; (delete-horizontal-space))) 


** my/fix-space

#+BEGIN_SRC emacs-lisp 
;;; new version
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]") 
            (looking-back"( ")
            (looking-at " )") 
            ) 
    (delete-horizontal-space)))
#+END_SRC

** self insert space 
#+BEGIN_SRC emacs-lisp
(defun insert-space ()
  (interactive)
  (let ((last-command-event ? ))
    (call-interactively 'self-insert-command)))
 
(global-set-key (kbd "M-SPC") 'insert-space)
#+END_SRC 


** kill word correctly
#+BEGIN_SRC emacs-lisp
;;; old version; remove after testing new one below
;; (defun kill-word-correctly ()
;;   "Kill word."
;;   (interactive)
;;   (expand-abbrev)
;;   (if (not(looking-at "[[:punct:]]")) ; if character at point is NOT a punctuation mark
;;     (progn                            ; THEN
;;   (kill-word 1) ; kill word
;;   (my/fix-space)) ; and fix space
;; (progn ; else 
;; (delete-forward-char 1) ; just delete the punctuation mark
;; (my/fix-space) ; and delete the space as well
;; )
;; ))

;;; new version
;; (defun kill-word-correctly ()
;;   "Kill word."
;;   (interactive)
;;   (expand-abbrev)
;;   (if (re-search-forward "\\=\\W*[[:punct:]]+\\W*\\<" nil t) ; IF there's a sequence of punctuation marks at point
;;       (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
;;     (kill-word 1))                                    ; ELSE kill word
;;   (my/fix-space)) ; and finally fix space

;;; newer version
(defun kill-word-correctly ()
  "Kill word."
  (interactive)
  (expand-abbrev)
  (if (or (re-search-forward "\\=[ 	]*\n" nil t)
          (re-search-forward "\\=\\W*?[[:punct:]]+" nil t)) ; IF there's a sequence of punctuation marks at point
      (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
    (kill-word 1))                                    ; ELSE kill word
  (my/fix-space))
#+END_SRC

** DONE [#A] kill word correctly and capitalize 
#+BEGIN_SRC emacs-lisp 
;;; old version; remove after testing new one
;; (defun kill-word-correctly-and-capitalize ()
;;   "Check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly."
;;   (interactive)
;; (if (my/beginning-of-sentence-p)
;;       (progn
;; (expand-abbrev)
;;   (if (re-search-forward "\\=\\W*[[:punct:]]+\\W*\\<" nil t) ; IF there's a sequence of punctuation marks at point
;;       (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
;;     (kill-word 1))                                    ; ELSE kill word
;;   (my/fix-space)
;; (capitalize-word 1) 
;; (left-word)
;; ) 
;; (progn
;; (expand-abbrev)
;;   (if (re-search-forward "\\=\\W*[[:punct:]]+\\W*\\<" nil t) ; IF there's a sequence of punctuation marks at point
;;       (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
;;     (kill-word 1))                                    ; ELSE kill word
;;   (my/fix-space)) ; and finally fix space 
;; ) 
;; )

;;; new version
;; (defun kill-word-correctly-and-capitalize ()
;;   "Check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly."
;;   (interactive)
;;   (let ((fix-capitalization (my/beginning-of-sentence-p)))
;;     (expand-abbrev)
;;     (if (re-search-forward "\\=\\W*[[:punct:]]+" nil t) ; IF there's a sequence of punctuation marks at point
;;         (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
;;       (kill-word 1))                                    ; ELSE kill word
;;     (my/fix-space)
;;     (when fix-capitalization
;;       (save-excursion (capitalize-word 1)))))

;;; newer version
(defun kill-word-correctly-and-capitalize ()
  "Check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly."
  (interactive)
  (let ((fix-capitalization (my/beginning-of-sentence-p)))
    (call-interactively 'kill-word-correctly)
    (when fix-capitalization
      (save-excursion (capitalize-word 1)))))
#+END_SRC


** TODO [#A] check my changes to backward kill word correctly? :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp 
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space) 

;; I added this ↓↓↓ #######################
(when (and 
(not (looking-back "---")) ; I added this 
(not (looking-back "^"))) ; I added this 
;; I added this ↑↑↑ #######################
 
(jay/insert-space) 
) 
)
#+END_SRC

** my-delete-backward                                       :rudi:
#+BEGIN_SRC emacs-lisp
;;; old versions; remove after testing new one
;; ;; delete backward one char unless the region is active: 
;; (defun my/delete-backward ()
;; "When there is an active region, delete it and then fix up the whitespace"
;;   (interactive)
;;   (if (use-region-p)                  ; IF
;;     (progn                            ; THEN
;;       (delete-region (region-beginning) (region-end))
;;       (my/fix-space)) 
;; (progn ; ELSE 
;;     (delete-backward-char 1)
;; (when (or (looking-back "^[[:space:]]+") 
;; (looking-at "[[:punct:]]"))
;; (delete-horizontal-space)) 
;; ))) 
;; 
;; ;; delete backward one char unless the region is active: 
;; (defun my/delete-backward ()
;; "When there is an active region, delete it and then fix up the whitespace"
;;   (interactive)
;;   (if (use-region-p)                  ; IF
;;     (progn                            ; THEN
;;       (delete-region (region-beginning) (region-end))
;;       (my/fix-space)) 
;; (progn ; ELSE 
;;     (delete-backward-char 1)
;; ))) 

;;; new version
;; delete backward one char unless the region is active: 
(defun my/delete-backward ()
  "When there is an active region, delete it and then fix up the whitespace"
  (interactive)
  (if (use-region-p)
      (delete-region (region-beginning) (region-end))
    (delete-backward-char 1))
  (save-excursion
    (when (or (looking-at "[[:space:]]")
              (looking-back "[[:space:]]"))
      (my/fix-space))))
#+END_SRC
*** TODO [#B] enable my-delete-backward to delete region and capitalize new first letter in sentence 
Rúdi: Can we add to my/delete-backward something like what I wrote below, so that if I delete a region containing the first part of a sentence or sentences, it automatically capitalizes the first letter of what is now the first word in the sentence?

#+BEGIN_QUOTE
First delete region, and then: 
(if (my/beginning-of-sentence-p)
(progn
(capitalize-word)
 (left-word)
))) 
#+END_QUOTE 

** timesvr

#+BEGIN_SRC emacs-lisp 
(defun timesvr ()
  "Task request to my virtual assistant."
  (interactive)
  (message-mail)
  (message-goto-subject) (insert "task request: " (format-time-string "%F %l:%M%P"))
  (message-goto-body) (insert "\n")
  )
(global-set-key (kbd "C-c t") 'timesvr)
(global-set-key (kbd "C-c m") 'compose-mail)
#+END_SRC

* Startup

#+BEGIN_SRC emacs-lisp
;; (toggle-maxframe)
(setq default-frame-alist
      '(
        (width . 160) ; character
        (height . 42) ; lines
        )) 
(zenburn)
(monaco-font) 
;; (minuscule-type)
(recenter-top-bottom)
#+END_SRC

* character movement
#+BEGIN_SRC emacs-lisp

(defun jay/left-char ()
  "Move point to the left or the beginning of the region.
 Like `backward-char', but moves point to the beginning of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'left-char)) ;; maintain compatibility
    (let ((left (min (point)
                     ;; `mark' returning nil is ok; we'll only use this
                     ;; if `mark-active'
                     (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn
            (goto-char left)
            (setq deactivate-mark t))
        (call-interactively 'left-char)))))


(defun jay/right-char ()
  "Move point to the right or the end of the region.
 Like `right-char', but moves point to the end of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'right-char)) ;; maintain compatibility
    (let ((right (max (point)
                      ;; `mark' returning nil is ok; we'll only use this
                      ;; if `mark-active'
                      (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn (goto-char right)
		 (setq deactivate-mark t))
	(call-interactively 'right-char)))))

(define-key org-mode-map (kbd "<left>") 'jay/left-char)
(define-key org-mode-map (kbd "<right>") 'jay/right-char)

#+END_SRC


* experiments - tested
#+BEGIN_SRC emacs-lisp
(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)
 
(define-key org-mode-map (kbd "<SPC>") 'jay/insert-space)

(defun reflash-indentation ()
"One sentence summary of what this command do."
  (interactive)
  (org-indent-mode 1)
  ) 
#+END_SRC
* experiments - new/untested
** macro to create defuns?

(defmacro make-my-function (name)
  (list 'defun (intern (format "my-%s-function" name)) ()
        (list 'interactive)
        (list (intern (format "mark-%s" name)))
        (list 'do-more-stuff)
        (list (intern (format "modify-%s" name))))) 

** saveplace
;; Save point position between sessions

#+BEGIN_SRC emacs-lisp
;; Save point position between sessions
(require 'saveplace)
(setq-default save-place t)
(setq save-place-file (expand-file-name ".places" user-emacs-directory))
#+END_SRC

The saveplace package is part of Emacs, and remembers the position of point - even between emacs sessions.

The last line sets the path to where saveplace stores your position data. Change it at your peril! 

** embolden next word

   #+BEGIN_SRC emacs-lisp

(define-minor-mode embolden-next-word
    "Make the next word you type bold."
  nil 
  :lighter " EMBOLDEN"
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "SPC") (lambda ()
                      (interactive)
                      (save-excursion 
                        (goto-char (get-register 'p))
                        (insert "*"))
                      (insert "* ")
                      (embolden-next-word -1)))
        (define-key map (kbd ".") (lambda ()
                    (interactive)
                    (save-excursion 
                      (goto-char (get-register 'p))
                      (insert "*"))
                    (insert "*. ")
                    (embolden-next-word -1)))
            map)
  (if embolden-next-word
      (set-register 'p (point))
    (set-register 'p nil)))

(global-set-key "\C-o" 'embolden-next-word) 
   #+END_SRC

** ideas
C-d on an empty line in the shell terminates the process.

(defun comint-delchar-or-eof-or-kill-buffer (arg)
  (interactive "p")
  (if (null (get-buffer-process (current-buffer)))
      (kill-buffer)
    (comint-delchar-or-maybe-eof arg)))

(add-hook 'shell-mode-hook
          (lambda ()
            (define-key shell-mode-map
              (kbd "C-d") 'comint-delchar-or-eof-or-kill-buffer)))
With this snippet, another press of C-d will kill the buffer.

It's pretty nice, since you then just tap C-d twice to get rid of the shell and go on about your merry way. 



Do you program any elisp, at all, ever?

;; Elisp go-to-definition with M-. and back again with M-,
(autoload 'elisp-slime-nav-mode "elisp-slime-nav")
(add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t)))
(eval-after-load 'elisp-slime-nav '(diminish 'elisp-slime-nav-mode))
Then you need to M-x package-install elisp-slime-nav-mode.

It lets you jump to the definition of a function with M-., and back again afterwards with M-,.

That last line says that we want elisp-slime-nav-mode to continue doing its work for us, but we no longer want to be reminded of it. 


** source code blocks
[[http://wenshanren.org/?p%3D334][Emacs：insert source code block in org-mode | 肉山博客 (Wenshan's Blog)]]


#+BEGIN_SRC emacs-lisp
(defun org-insert-src-block (src-code-type)
  "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
  (interactive
   (let ((src-code-types
          '("emacs-lisp" "css"
"dot"

"latex")))
     (list (ido-completing-read "Source code type: " src-code-types))))
  (progn
    (newline-and-indent)
    (insert (format "#+BEGIN_SRC %s\n" src-code-type))
    (newline-and-indent)
    (insert "#+END_SRC\n")
    (previous-line 2)
    (org-edit-src-code)))

(local-set-key (kbd "C-c v e")
               'org-edit-src-code)
;; keybinding for inserting code blocks
(local-set-key (kbd "C-c v i")
               'org-insert-src-block) 
#+END_SRC

** hunspell 

   #+BEGIN_SRC emacs-lisp

(when (executable-find "hunspell")
  (setq-default ispell-program-name "hunspell")
  (setq ispell-really-hunspell t)) 
(setq flyspell-default-dictionary "en_US")

(setq ispell-dictionary "en_US")
(setq ispell-program-name "/usr/local/bin/hunspell") 
(setenv "DICTIONARY" "en_US") 
(if (file-exists-p "/usr/bin/hunspell")
    (progn
      (setq ispell-program-name "hunspell")
      (eval-after-load "ispell"
        '(progn (defun ispell-get-coding-system () 'utf-8))))) 

(executable-find "hunspell")
;;  (setq ispell-program-name "hunspell")
;;(setq ispell-local-dictionary-alist '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil nil nil utf-8))) (setq ispell-extra-args '("-d en_US") 
(flyspell-mode-on) 
   #+END_SRC

References:
[[http://emacswiki.org/emacs/InteractiveSpell#toc2][EmacsWiki: Interactive Spell]]
[[https://lists.gnu.org/archive/html/help-gnu-emacs/2015-03/msg00153.html][Getting flyspell + hunspell to work on OS X 10.10]]
[[https://joelkuiper.eu/spellcheck_emacs][Spell checking in Emacs]]
[[http://stackoverflow.com/questions/25415070/hunspell-emacs-on-os-x-10-9][hunspell / emacs on OS X 10.9 - Stack Overflow]]
[[http://stackoverflow.com/questions/3961119/working-setup-for-hunspell-in-emacs][Working setup for hunspell in Emacs - Stack Overflow]]
[[http://unix.stackexchange.com/questions/86554/make-hunspell-work-with-emacs-and-german-language][spell checking - Make hunspell work with emacs and german language - Unix & Linux Stack Exchange]]
[[http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html][What's the best spell check setup in emacs | Chen's blog]]
[[http://www.lonecpluspluscoder.com/2015/03/setting-up-emacs-spell-checking-on-os-x/][Setting up Emacs spell checking on OS X - The Lone C++ Coder's Blog]]
 

* Helm Org Wiki

I'm using an extremely simplistic approach: just dump all the org
files into one directory.  The name of each org file should be concise
but descriptive, e.g. Makefile.org describes Makefiles, and git.org
describes git.

This simplicity completely alleviates organization effort: there's
nothing to organize, since there's only one directory to put the files in.
At the same time, it's very accessible by means of two `helm` wrappers:

- globally, "C-0" runs the command helm-org-wiki (the code is below)
- in org-mode, "g" runs the command wspecial-worf-goto (the code is at
https://github.com/abo-abo/worf)

It's like a two-stage personal Google: the first stage is to find an org-file,
the second stage is to search within an org-file.

For example, here's the sequence of key bindings when I want to look
up how git bisect works, assuming that I'm in some random buffer, like
`ansi-term`:

        C-0 gi RET g bis RET

Done. Note that "gi" was enough to match "git.org", since all my other
pages don't contain "gi".  Same thing for "bis" being able to match
uniquely the heading "git bisect".  I think that it's quite optimal
that I'm able to find the topic "git bisect" by using only 10 key
presses, which is the same as the amount of characters in "git
bisect".  Compare this to `helm-google-suggest` (bound to "C-p g"):

        C-p g git bi RET TAB RET

That's 12 key presses (10 in Emacs, 2 in Firefox).

New wiki pages can be created with "C-0" as well, just type in the
name of the new file and hit RET.

That's it, the code is below. It's very similar to `org-switchb`,
except that the files need not be opened to appear in the completion
list, and new files are created if there's no match.

regards,
Oleh
(Source: http://lists.gnu.org/archive/html/emacs-orgmode/2014-04/msg01134.html) 

#+BEGIN_SRC emacs-lisp 
    (defgroup helm-org-wiki nil
      "Simple jump-to-org-file package."
      :group 'org
      :prefix "helm-org-wiki-")
    (defcustom helm-org-wiki-directory "~/nd/"
      "Directory where files for `helm-org-wiki' are stored."
      :group 'helm-org-wiki
      :type 'directory)
    (defun helm-org-wiki-files ()
      "Return .org files in `helm-org-wiki-directory'."
      (let ((default-directory helm-org-wiki-directory))
        (mapcar #'file-name-sans-extension
                (file-expand-wildcards "*.txt"))))
    (defvar helm-source-org-wiki
      `((name . "Projects")
        (candidates . helm-org-wiki-files)
        (action . ,(lambda (x)
                      (find-file (expand-file-name
                                  (format "%s.txt" x)
                                  helm-org-wiki-directory))))))
    (defvar helm-source-org-wiki-not-found
      `((name . "Create org-wiki")
        (dummy)
        (action . (lambda (x)
                    (helm-switch-to-buffer
                     (find-file
                      (format "%s/%s.org"
                              helm-org-wiki-directory x)))))))
    ;;;###autoload
    (defun helm-org-wiki ()
      "Select an org-file to jump to."
      (interactive)
      (helm :sources
            '(helm-source-org-wiki
              helm-source-org-wiki-not-found)))
    (provide 'helm-org-wiki)

#+END_SRC


* Emacs Lisp Mode
#+BEGIN_SRC emacs-lisp 
(defun turn-on-autocomplete-mode ()
   (auto-complete-mode 1))
(add-hook 'emacs-lisp-mode-hook 'turn-on-autocomplete-mode )
#+END_SRC
 
* Reference for cleaning up whitespace around sentences:
[[http://stackoverflow.com/questions/4754547/redefining-sentence-in-emacs-single-space-between-sentences-but-ignoring-ab][regex - Redefining "sentence" in Emacs? (single space between sentences, but ignoring abbreviations) - Stack Overflow]]

* cycle-hyphenation 

#+BEGIN_SRC emacs-lisp
(defun cycle-hyphenation ()
  (interactive)
  (cond ((re-search-forward "\\=\\w*\\(-\\)\\w+" nil t)
         (save-excursion (replace-match " " t t nil 1)))
        ((re-search-forward "\\=\\w*\\( +\\)\\w+" nil t)
         (save-excursion (replace-match "-" t t nil 1)))))
#+END_SRC

* clone subtree 
#+BEGIN_SRC emacs-lisp
(defun org-clone-subtree ()
  (interactive)
  (org-clone-subtree-with-time-shift 1)
  (save-excursion
    (org-goto-sibling)
    ;; This part was lifted partly and adapted from
    ;; http://orgmode.org/worg/org-hacks.html#orgheadline10.
    ;; There should be a better way to change the contents of an org heading
    ;; though...
    (when (org-at-heading-p)
      (let ((hl-text (nth 4 (org-heading-components)))
            (buffer-undo-list))
        (when hl-text
          (beginning-of-line)
          (search-forward hl-text (point-at-eol))
          (replace-match (format "%s - original" hl-text) nil t)
          (org-align-tags-here org-tags-column))))))
#+END_SRC

* smart punctuation 

** kill-clause

#+BEGIN_SRC emacs-lisp
;; Identify the end of sentences globally.
(setq sentence-end-base "[][.?!…\"'”)}]+")

;;; old version; remove after testing new one
;; Clauses are like sentences, but with some additional end markers. Rebind `sentence-end-base' locally to get that effect.
;; (defun kill-clause ()
;;   (interactive) 
;;   (expand-abbrev)
;;   (let ((sentence-end-base "--\\|[][,;.?!…\"'”()}]+"))
;;     (my/kill-sentence-dwim)))

;;; new version
(defun kill-clause ()
  (interactive) 
  (expand-abbrev)
  (let ((old-point (point))
        (kill-punct (my/beginning-of-sentence-p)))
    (when (re-search-forward "--\\|[][,;:?!…\"”()}]+\\|\\.+ " nil t)
      (kill-region old-point
                   (if kill-punct
                       (match-end 0)
                       (match-beginning 0)))))
  (my/fix-space))
#+END_SRC

** smart-punctuation exceptions

   #+BEGIN_SRC emacs-lisp
(defvar *smart-punctuation-marks*
  ".,;:!?-")

(setq *smart-punctuation-exceptions*
  (list "?!" ".." "..." "---" "!!!" "!:")) 
   #+END_SRC


** smart-punctuation (auxiliary)

#+BEGIN_SRC emacs-lisp 

(defun smart-punctuation (new-punct &optional not-so-smart)
  (expand-abbrev)
  (let ((old-point (point)))
    ;; 1. go back until there are no more spaces/tabs
    (when (re-search-backward "[^ 	][ 	]+\\="
                              nil t)
      (forward-char 1))
    (flet ((replace (text)
             (let ((nr-new-chars (- (length text) (length (match-string 1)))))
               (replace-match text t t nil 1)
               (goto-char old-point)
               (forward-char nr-new-chars))))
      (let (exception)
        (cond ((or not-so-smart
                   (not (re-search-backward (format "[^%s]\\([%s]+\\)\\="
                                                    *smart-punctuation-marks*
                                                    *smart-punctuation-marks*)
                                            nil t)))
               ;; 2.1. if there's not a series of punctuation marks, or if we
               ;; don't want to replace (`not-so-smart'), just insert the
               ;; `new-punct', and move to the `old-point' + the length of
               ;; `new-punct'.
               (insert new-punct)
               (goto-char old-point)
               (forward-char (length new-punct)))
              ((setf exception
                     (let ((potential-new-punct
                            (concat (match-string 1) new-punct)))
                       (find-if (lambda (exception)
                                  (search potential-new-punct exception))
                                *smart-punctuation-exceptions*)))
               ;; 2.2. if the series of punctuation marks concatenated with
               ;; `new-punct' form (even if partially) an exception, then replace
               ;; it with that exception and fix the spaces.
               (replace exception))
              (t
               ;; 2.3. if there is a series of punctuation marks and there is no
               ;; matching exception, replace by the `new-punct' and fix the
               ;; spaces.
               (replace new-punct)))))))
#+END_SRC

** smart-period
#+BEGIN_SRC emacs-lisp 
(defun smart-period ()
  (interactive)
  (smart-punctuation "."))

(define-key org-mode-map (kbd ".") 'smart-period)
#+END_SRC

** smart-comma
#+BEGIN_SRC emacs-lisp 
(defun smart-comma ()
  (interactive)
  (smart-punctuation ","))

(define-key org-mode-map (kbd ",") 'smart-comma)
#+END_SRC

** smart-question-mark
#+BEGIN_SRC emacs-lisp 
(defun smart-question-mark ()
  (interactive)
  (smart-punctuation "?"))

(define-key org-mode-map (kbd "?") 'smart-question-mark)
#+END_SRC

** smart-exclamation-point
#+BEGIN_SRC emacs-lisp 
(defun smart-exclamation-point ()
  (interactive)
  (smart-punctuation "!"))

(define-key org-mode-map (kbd "!") 'smart-exclamation-point)
#+END_SRC

** smart-hyphen
(defun smart-hyphen ()
  (interactive)
  (smart-punctuation "-"))

(define-key org-mode-map (kbd "-") 'smart-hyphen)
#+END_SRC

** smart-semicolon

#+BEGIN_SRC emacs-lisp 
(defun smart-semicolon ()
  (interactive)
  (smart-punctuation ";" t))

(define-key org-mode-map (kbd ";") 'smart-semicolon)
#+END_SRC

** smart-colon

#+BEGIN_SRC emacs-lisp 
(defun smart-colon ()
  (interactive)
  (smart-punctuation ":" to))

;; (define-key org-mode-map (kbd ":") 'smart-colon)
#+END_SRC

* DONE [#B] yet another edge case for kill-word-correctly-and-capitalize 
Here's another edge case. 

: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought thought Alice, "without pictures or conversations?" 

Suppose the point is on the "t" in the first "thought" and I invoke kill-word-correctly-and-capitalize. 

Current output: 
: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book,"thought Alice, "without pictures or conversations?"

Desired output:
: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought Alice, "without pictures or conversations?" 

This function is becoming more and more useful!

** NOTE-TO-JAY Question

   The culprit here seems to be again ~my/fix-space~. I see you added the following clause:

: (looking-back "\" ") 

   This means that after fixing the spaces, if you look back from point to '" ', you should delete the space. I suppose that's only true if: (1) the quotation marks are starting a quote, or (2) there is a punctuation mark ahead (which is handled by another clause).

   So, what was the intention here?
*** NOTE-TO-RÚDI Answer
Hmm, I'm not sure I remember what I intended there. I must have been trying to address an edge case I found myself. If it makes sense to remove that clause again, let's do so, and if I find another edge case, we can address it at that point.

In general, I will use quotation marks and punctuation in the style/sequence reflected below: 

#+BEGIN_QUOTE
Alice was beginning to get very tired of sitting by her sister on the bank (and of having nothing to do). Once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought Alice, "without pictures or conversations."
#+END_QUOTE

Thanks!

*** NOTE-TO-JAY About the quotation marks

OK, I removed the clauses pertaining to the quotation marks. Indeed, it is hard to determine, when you are looking at a single quotation mark, if it is starting or ending the quote. You must pair it with the previous or next; in the limit you have to take into account the whole buffer. There is probably code out there that does it (note that ~emacs-lisp-mode~, for example, colourises strings -- therefore, it must know when a string starts or ends). I can search for it if you want.
*** NOTE-TO-RÚDI later
Yes, that would be great, but let's deprioritize it. Thanks!


#+BEGIN_SRC emacs-lisp
(defvar *punctuation-markers-to-cycle-between*  ".?!")

(defun cycle-punctuation ()
  (interactive)
  (save-excursion
    (forward-sentence)
    (when (re-search-backward (format "\\>\\([%s]\\)[[:space:]]*\\="
                                      *punctuation-markers-to-cycle-between*)
                              nil t)
      (let ((next (elt *punctuation-markers-to-cycle-between*
                       ;; circular string; should be abstracted
                       (mod (1+ (position (elt (match-string 1) 0)
                                          *punctuation-markers-to-cycle-between*))
                            (length *punctuation-markers-to-cycle-between*)))))
        (replace-match (format "%c" next) t t nil 1)))))

(define-key key-minor-mode-map (kbd "M-.") 'cycle-punctuation) 
#+END_SRC

* TODO [#C] request: backspace after expand-abbrev 
Hi Rúdi,

To complete the cycle on all these enchancesments to how Emacs handles spacing and abbrev expansion, I want to create a better way to correct typos. 

The problem is that if I make a typographical error when I'm typing an abbrev, it becomes difficult to correct it. 

See below. 

<KB>bc </KB> 
output: 
#+BEGIN_EXAMPLE: 
because ^
#+END_EXAMPLE:

<KB>bg </KB> 
output: 
#+BEGIN_EXAMPLE: 
beginning ^
#+END_EXAMPLE:

Let's say I accidentally type "bg" when I meant to type "bc". Now I'm at the end of the word beginning. If I hit BACKSPACE (my/delete-backward) I now have to delete through an entire unwanted word.

Is it possible (and not too difficult) to make it so that if I invoke my/delete-backward within a few keystrokes of Emacs running expand-abbrev, to run unexpand-abbrev automatically? Thanks!

** NOTE-TO-JAY Question

    The question here is: what do you mean by "within a few keystrokes"?

    So, suppose you define a parameter that determines the maximum amount of keystrokes before Emacs "forgets" about ~expand-abbrev~. Let's say its value is 5 and let's take your example:

<KB>bg </KB> 
output: 
#+BEGIN_EXAMPLE: 
beginning ^
#+END_EXAMPLE:

Suppose you now type "oops" (four keystrokes). You get:

#+BEGIN_EXAMPLE: 
beginning oops^
#+END_EXAMPLE:

What should happen when you ~my/delete-backward~? I can imagine two scenarios:

1. Delete the 's'. Further ~my/delete-backward~ invocations would delete each individual character downto the first 'o', then on the *fifth*, 'beginning' would be unexpanded.
2. Unexpand 'beginning'. Further invocations would delete the characters (starting in 's', etc).

My personal opinion: 2, albeit easier to implement, would be messy. Suppose you really did mean to write 'beginning', but not 'oops'. You'd have to type some more, or perhaps make inocuous keystrokes just to get Emacs to forget about unexpanding, and *only* then you could ~my/delete-backward~.

3. Perhaps another option: binding a similar keyboard combination (say M-<backspace>, C-M-<backspace>, or C-M-S-<backspace>) to ~unexpand-abbrev~. Did you consider this? Why didn't it convince you?

** NOTE-TO-RÚDI Answer
Definitely #1. if possible, #1 would be great. #3 could work also. it's just a bit easier to type BACKSPACE 5 times than it is to type it 4 times followed by C-BACKSPACE. but this is also an option if #1 is pretty complicated. Either way, let's make this a low-priority request.

** NOTE-TO-JAY Clarification

   I think I didn't make myself clear about what I meant with 3. My suggestion was to add a keybinding of C-BACKSPACE to ~unexpand-abbrev~, so you wouldn't have to BACKSPACE at all in order to unexpand. For example, you'd type:

: bg^

   But you had wanted to type 'bc'. When you hit space, Emacs expands it to 'beginning'. Unaware of the typo, you'd keep going:

: beginning Emacs is great!^

   When you'd finish typing, you'd realise the mistake and would hit C-BACKSPACE, which would ~unexpand-abbrev~, and leave point after the unexpanded text:

: bg^ Emacs is great!

   This way, unexpanding and deleting is totally independent (well, as long as you don't delete the expanded word :) ). Of course if you want to also delete the text after the expansion you can use BACKSPACE, or even kill words.

* TODO [#B] in shared-functions.org, make the function replace-smart-quotes operate on pasteboard contents when there is no region set?
And can we create a function pasteboard-paste-without-smart-quotes that does replace-smart-quotes on the OSX pasteboard contents, then runs pasteboard-paste? Thanks!

** NOTE-TO-JAY Request for clarification

   I'm not quite sure I understand the requests. You intend to actually *alter* the pasteboard contents? What is the purpose of that? By your request I imagine you'd want to copy from the web some snippet with smart quotes, like:

: These are smart quotes: “ ” ‘ ’

   Then run ~replace-smart-quotes~, and the next time you'd yank, you'd get:

: These are smart quotes: " " ' '

   But note that if you'd paste it onto another program, you'd get this latter string too.

   I know there is an API to access pasteboard contents (~ns-get-pasteboard~, ~ns-set-pasteboard~), but since I'm not running an OS X, it is difficult for me to check that... but not impossible. 

   Now, there is an alternative, which would be to ~pasteboard-paste~, and *then* ~replace-smart-quotes~ over the pasted text. I think this would be cleaner, since it wouldn't interfere with the pasteboard.
** NOTE-TO-RÚDI answer 
Yes, this second solution should work! 

* DONE [#A] disable cycling between hyphen and ellipsis?
Can you disable cycling between hyphen and ellipsis? It's a great idea but I realize there are times when I want to type a long line of 30 periods in a row (without using the number prefix). Should I just add ".........................." to smart-punctuation-exceptions? Thanks!

** NOTE-TO-JAY Answer

   Yes, adding that as an exception should work. 

* TODO [#B] smart-return
Can we create a function smart-return? In org-mode, I will bind (kbd <RETURN>) to it. 

A function that will:
1. Insert line break (obviously)
2. When there is a region set, REPLACE region with a line break, the same way a highlighted region is already replaced if you had an alphanumeric key.
3. Check to see if point is in a plain-text list, and if so, run org-meta-return instead of return

Example:

#+BEGIN_EXAMPLE
- first item
- second item^ 
#+END_EXAMPLE

Suppose the carat ^ represents where the point is, and I hit <RETURN>.

Current output:
#+BEGIN_EXAMPLE
- first item
- second item 
^ 
#+END_EXAMPLE

Desired output:
#+BEGIN_EXAMPLE
- first item
- second item 
* - ^
#+END_EXAMPLE

Does that make sense? Thanks!

* TODO [#A] parentheses and auto-capitalize mode
OK, I think when we modified kill-clause to recognize parentheses as punctuation, it had an unintended consequence: auto-capitalize-mode now counts parentheses as periods. This behavior just started.

Let's say I enter the text:

: Alice (who was very curious indeed) was beginning to get very tired. 

Now let's say I enter it with auto-capitalize-mode on. 

Current output:
Alice (who was very curious indeed) Was beginning to get very tired. 

Desired output: 
Alice (who was very curious indeed) was beginning to get very tired. 

Can we fix? Thanks! 
