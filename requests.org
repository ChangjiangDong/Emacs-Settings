* file settings                                                     :ARCHIVE:
#+OPTIONS: f:t 
#+TODO: TODO PLEASE-CLARIFY PLEASE-TEST TESTING PLEASE-DEBUG | DONE
#+TODO: | NOTE-TO-JAY NOTE-TO-RUDI NOTE-TO-RÚDI
#+TODO: PLEASE-CHECK-MY-INEPT-CODE PLEASE-HELP-ME-DEBUG-MY-INEPT-CODE | TRY-THIS
#+TITLE: 
#+TITLE: #+TITLE: Jay Dixit's GNU Emacs setup 



* TODO Change "defadvice capitalize-word" so that capitalize word doesn't downcase past a line break 
See [[file:gnu-emacs-startup.org::*Change%20"defadvice%20capitalize-word"%20so%20that%20capitalize%20word%20doesn't%20downcase%20past%20a%20line%20break][this]]. 

* DONE [[file:shared-functions.org::*new-email-from-subtree][new-email-from-subree]]
   I can't seem to reproduce the problem. It seems to work well for me. What is the error/undesired behaviour you're getting?

** NOTE-TO-RÚDI fixed
Not sure what changed, but I'm confirming that this is working now. 

* PLEASE-TEST [#C] strange behavior with smart-comma (see [[file:smart-punctuation-error.org::*in%20the%20example%20below:][smart-punctuation-error.org]])
I can't seem to reproduce the reported bugs/undesired behaviours. Perhaps they went away when I refactored the ~smart-punctuation~ function? Are you still getting them?

** NOTE-TO-RÚDI still getting the error
I still get an error when I follow the directions [[file:smart-punctuation-error.org::*how%20to%20induce%20the%20error:][here]]. It's when I try to place a comma in the heading at the bottom of the file. Can you try doing this and tell me if you can reproduce the error? Thanks! 

* TODO don't autocapitalize checklist items
- [ ] This
- [ ] That
- [ ] And this 

These get autocapitalized... can we disable that?

* TODO capitalize first character of new line after ellipsis
In a sentence like this... autocapitalize does not capitalize after the ellipsis. This is as desired.

However, sometimes an ellipsis occurs at the end of a paragraph...

in these cases, the first letter of the new sentence on 
^ the new line SHOULD be capitalized. Can we fix? Thanks! 

* TODO kill-clause
** NOTE-TO-JAY Questions 
     Regarding ~pasteboard-cut~, I think it's rather straightforward. Please give it a go.

     As for ~kill-line~, there's something I should clarify: this is a builtin command (comes with Emacs), so it's not something I can easily change. Except that Emacs Lisp has a nice little functionality called "advicing", which allows dynamically adding behaviour to functions without having access to their code. I could do this to ~kill-line~. However, this is usually not recommended, since it could mess up other functionalities that might depend on the default ~kill-line~ implementation. Anyway, since you have the ~my/kill-line-dwim~ function, isn't that the one you use?

     Finally, regarding ~kill-clause~, I added the requested functionality, but I realised the implementation has several probably undesired behaviours. For example:

: This is a test sentence^, nothing to see here. And then another.

     Caret marks the point. In this case, calling ~kill-clause~ results in:

: This is a test sentence, ^nothing to see here. And then another.

     I.e. it only moves point. Please confirm that it should yield:

: This is a test sentence^. And then another.

     Now, going back to the current result of ~kill-clause~:

: This is a test sentence, ^nothing to see here. And then another.

     If you now invoke ~kill-clause~, you'll have:

: This is a test sentence, . ^And then another.

     This also seems silly. Again, it would seem reasonable to produce:

: This is a test sentence^. And then another.

     Finally, I found an edge case:

: This is a test sentence, nothing to see here. ^And then another.<EOB>

     Where <EOB> marks the end of the buffer. In this case, nothing happens when you invoke ~kill-clause~. I suppose it should kill the entire sentence:

: This is a test sentence, nothing to see here.^<EOB>

     Correct?

** NOTE-TO-RÚDI Answers for kill-clause below.

This is a test sentence^, nothing to see here. And then another.

     Caret marks the point. In this case, calling ~kill-clause~ results in:

This is a test sentence, ^nothing to see here. And then another.

     I.e. it only moves point. Please confirm that it should yield:

This is a test sentence^. And then another.

: Yes! Confirmed, that is what it should yield. 

     Now, going back to the current result of ~kill-clause~:

This is a test sentence, ^nothing to see here. And then another.

     If you now invoke ~kill-clause~, you'll have:

This is a test sentence, . ^And then another.

     This also seems silly. Again, it would seem reasonable to produce:

This is a test sentence^. And then another.

: Yes, exactly! That would be the desired behavior. However, the optimal point placement for that case would be this:
This is a test sentence. ^And then another.


     Finally, I found an edge case:

This is a test sentence, nothing to see here. ^And then another.<EOB>

     Where <EOB> marks the end of the buffer. In this case, nothing happens when you invoke ~kill-clause~. I suppose it should kill the entire sentence:

This is a test sentence, nothing to see here.^<EOB>

     Correct?

: Correct! Thanks for thoroughly thinking through these cases, much appreciated! 

** NOTE-TO-RÚDI Comments about my edits to kill-clause-test-file.el 
What a brilliant approach, to create the test file! Here are some notes about my edits to the file.

Kill-clause should only kill one clause, which I think means it should only ever kill one comma, not two. So for the example below, it should leave the second comma in. I edited the desired output in kill-clause-test-file.el.

Input: We should consider^, for completeness, comma separated clauses. 
Your suggested output: We should consider^ comma separated clauses.
My desired output: We should consider^, comma separated clauses. 

Same for this one:

Input: We should consider,^ for completeness, comma separated clauses.
Your suggested output: We should consider^ comma separated clauses.
My desired output: We should consider,^ comma separated clauses. 

And this one:

Input: We should consider, ^for completeness, comma separated clauses.
Your suggested output: We should consider^ comma separated clauses.
My desired output: We should consider, ^comma separated clauses. 

With the example below, it should kill the question mark and leave the period. And the point should be before the period.

Input: And what about two consecutive sentences^? That's important too.
Your suggested output: And what about two consecutive sentences?^
My desired output: And what about two consecutive sentences^.

With the example below, I probably would never have the input you mentioned. I changed the syntax of the input to match the case I'm more likely to encounter. 

Your suggested input: ^Let's not forget parenthesis (those are extremely important!)
My more likely input: ^Let's not forget parenthesis (those are extremely important)! 
Output: (^Those are extremely important)! 

Same for this one:

Your suggested input: Let's not forget parenthesis ^(those are extremely important!) 
My more likely input: Let's not forget parenthesis ^(those are extremely important)! 
Output: Let's not forget parenthesis^! 

Thanks! 

** NOTE-TO-RÚDI I reviewed kill-clause-test-file.el 
Thanks for the question about kill-clause-test-file.el. I reviewed the file and did find an error, which I corrected. The rest is as I intend it. I realize some of the desired behaviors may seem strange. But I'm crafting the tests with my specific editing habits in mind. I guess the main point is that when I use kill clause, usually I do so because I intend to write more words /within that clause/, not after it. In any case, the tests in the file will be an accurate gauge of the desired behavior. Thanks again! :-)

* TODO [#C] create an auto-capitalization-predicate-exceptions-list?
I'd like to create a plain-text list of words that are exceptions to auto-capitalization. So for e.g. if I type e.g. like I have in this sentence, I don't want the next word to be automatically capitalized. 

See my existing code: 

#+BEGIN_SRC emacs-lisp
(setq auto-capitalize-predicate
      (lambda () (not (looking-back "\\([Ee]\\.g\\|[Uu]\\.S\\|[Ii]\\.e\\|\\.\\.\\)\\.[^.]*" (- (point) 20)))))
#+END_SRC

This works. However, I'd like to be able to keep this list in a plain text format and add to it. The reason I'm asking is because I wanted to add the word "vs." to the list (e.g. "good vs. evil") but I couldn't get the regexp correct with all the slash escaping. It would be easier if the list looked something like this: 

#+BEGIN_SRC emacs-lisp
(setq *auto-capitalize-exceptions*
  (list "e.g." "i.e. " "vs." "..." "- [ ] ")) 
#+END_SRC

Thanks!

* TODO [#C] a tweak to my/kill-sentence-dwim 
I created a test file my-kill-sentence-dwim-test-file.elt to illustrate input and desired output for an edge case I discovered. Thanks!
** 
* TESTING [#B] a smart-space exception for org-mode tags

Example:
#+BEGIN_EXAMPLE
* Is this a viable^                                                   :slide: 
#+END_EXAMPLE

Let's say the point is on the carat and I type "business?"

Current output: 
#+BEGIN_EXAMPLE
* Is this a viable business ?slide: 
#+END_EXAMPLE

Desired output:
#+BEGIN_EXAMPLE
* Is this a viable business?^                                          :slide: 
#+END_EXAMPLE

*** NOTE-TO-RÚDI Question about spaces?
It works! Now, next question. Currently, when I type spaces between words in the heading, the space between the words and the tag gets collapsed. (Obviously it does, since I have <SPC> bound to jay/insert-space.) Is it easy to make it so that I can type spaces in the heading with collapsing the spaces between the heading and the tag? If it's too complicated, I can solve this problem on the "user side" by trying to remember to use M-SPC (insert-space) whenever I'm in an org-mode heading with a tag. 

* TODO capitalize after ellipsis and line breaks

e.g. 

This is the end...

but this is a new beginning. 

But should be autocapitalized. 



* TODO an edge case for kill-word-correctly-and-capitalize 

Input: The 16/8 doesn't appeal to me as much.^ And also based on what Varady hypothesized about reduced caloric intake being mediated by stomach shrinkage on fast days 

Scenario: kill-word-correctly-and-capitalize

Current output: The 16/8 doesn't appeal to me as much. also based on what Varady hypothesized about reduced caloric intake being mediated by stomach shrinkage on fast days 

Desired output: The 16/8 doesn't appeal to me as much. Also based on what Varady hypothesized about reduced caloric intake being mediated by stomach shrinkage on fast days 


* TODO a change to endless downcase 
In [[file:shared-functions.org::*Intelligently%20change%20punctuation%20of%20sentences%20when%20I%20change%20the%20capitalization][endless/downcase]], don't convert "..." to "..,"

Input: The only thing we have to fear... ^Is fear itself.
Scenario: invoke ~endless/downcase~
Current output: The only thing we have to fear.., is^ fear itself. 
Desired output: The only thing we have to fear... is^ fear itself.

* TODO pasteboard-paste-without-smart-quotes 
I'm finding that pasteboard-paste-without-smart-quotes inserts rogue spaces in the pasted contents. Doesn't happen every time... but it happens often. Can you reproduce / debug? Thank you!!

* TODO smart comma
When point is on a period, exclamation point, or question mark and it hit "," then next word should also be downcased. Basically, if I'm changing a period to a comma, next word should be downcased.

Input: I'd like to stay^. But I'm late.
Scenario: Point is on the period and I type a comma (",") 
Current output: I'd like to stay,^ But I'm late. 
Desired output: I'd like to stay,^ but I'm late. 
