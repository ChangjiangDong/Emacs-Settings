* file settings                                                     :ARCHIVE:
#+OPTIONS: f:t 
#+TODO: TODO PLEASE-TEST TESTING PLEASE-DEBUG | DONE
#+TODO: | NOTE-TO-JAY NOTE-TO-RUDI NOTE-TO-RÚDI
#+TODO: PLEASE-CHECK-MY-INEPT-CODE PLEASE-HELP-ME-DEBUG-MY-INEPT-CODE | TRY-THIS
#+TITLE: 
#+TITLE: #+TITLE: Jay Dixit's GNU Emacs setup 



* NOTE-TO-RÚDI priorities
If you could tackle the requests in the following order, that would be amazing: 

** DONE [#A] strange behavior with smart-period? (See below)
** TODO [#A] requests.org: smart-punctuation when there's already a misplaced punctuation mark
** TODO [#A] gnu-emacs-startup.org: [[file:gnu-emacs-startup.org::*Change%20"defadvice%20capitalize-word"%20so%20that%20capitalize%20word%20doesn't%20downcase%20past%20a%20line%20break][Change "defadvice capitalize-word" so that capitalize word doesn't downcase past a line break]]
** TODO [#A] [[file:shared-functions.org::*erika-send-email-styled][erika-send-email-styled]] (I changed my setup, see my note)
** TODO [#A] [[file:shared-functions.org::*new-email-from-subtree][new-email-from-subtree]]
** TODO [#A] [[*add%20"capitalize%20first%20word%20of%20next%20sentence"%20to%20smart-period,%20smart-question-mark,%20and%20smart-exclamation%20mark][add "capitalize first word of next sentence" to smart-period, smart-question-mark, and smart-exclamation mark]]
** TODO priority B requests
** TODO [#C] kill-clause etc.

Thanks again!

* open requests 
** Emacs 

*** TODO smart-punctuation behaviors 
**** TODO [#A] smart-punctuation when there's already a misplaced punctuation mark?
Can we adjust the behavior of smart-punctuation somewhat for the edge case of dealing with a sentence that already has a misplaced punctuation mark (i.e. there's a space between the word and the punctuation mark.

Example:

: You might have a conscious intention to eat healthier , but you forget.

Say the point is on the comma. 

Current behavior: no effect.

Desired behavior: 
: You might have a conscious intention to eat healthier, but you forget.

**** TESTING [#A] smart-punctuation when there's already a correctly placed punctuation mark
Example:

: You might have a conscious intention to eat healthier, but you forget.

Say the point is on the comma and I hit comma. Current behavior is to do nothing and keep the point on the comma. But this is counterintuitive, because if there is NO comma and I hit comma, it gives me a comma, my point is placed on the space AFTER the comma. I'd like to replicate this behavior---hitting comma gives consistent behavior regardless of whether there is an existing comma or not. 

Same thing if I hit ! or ? or . or ; and change the punctuation. Whenever I hit one of those punctuation marks, the point should be placed AFTER the punctuation mark, not stay on it. Thanks!! 

***** NOTE-TO-JAY Test files

      I added some test files: [[file:smart-period-test.elt][smart-period-test.elt]] and [[file:smart-comma-test.elt][smart-comma-test.elt]] with several examples of the use of these functions (the other smart punctuation marks should be similar). Please review them.

**** NOTE-TO-JAY Try it now

     I refactored ~smart-punctuation~, and now it passes all test cases for period, comma, and colon, which I also added a test file for. Please check if it is working as intended and, otherwise, provide the test cases where it is not.

*** TODO [#B] kill-line-and-capitalize [1/3]
Can you add something like this: 

(save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-word 1))))

to:

- [X] pasteboard-cut.
- [ ] kill-line. EDIT: I should have said my/kill-line-dwim 
- [ ] kill-clause.

Thanks! 

**** NOTE-TO-JAY Questions

     Regarding ~pasteboard-cut~, I think it's rather straightforward. Please give it a go.

     As for ~kill-line~, there's something I should clarify: this is a builtin command (comes with Emacs), so it's not something I can easily change. Except that Emacs Lisp has a nice little functionality called "advicing", which allows dynamically adding behaviour to functions without having access to their code. I could do this to ~kill-line~. However, this is usually not recommended, since it could mess up other functionalities that might depend on the default ~kill-line~ implementation. Anyway, since you have the ~my/kill-line-dwim~ function, isn't that the one you use?

     Finally, regarding ~kill-clause~, I added the requested functionality, but I realised the implementation has several probably undesired behaviours. For example:

: This is a test sentence^, nothing to see here. And then another.

     Caret marks the point. In this case, calling ~kill-clause~ results in:

: This is a test sentence, ^nothing to see here. And then another.

     I.e. it only moves point. Please confirm that it should yield:

: This is a test sentence^. And then another.

     Now, going back to the current result of ~kill-clause~:

: This is a test sentence, ^nothing to see here. And then another.

     If you now invoke ~kill-clause~, you'll have:

: This is a test sentence, . ^And then another.

     This also seems silly. Again, it would seem reasonable to produce:

: This is a test sentence^. And then another.

     Finally, I found an edge case:

: This is a test sentence, nothing to see here. ^And then another.<EOB>

     Where <EOB> marks the end of the buffer. In this case, nothing happens when you invoke ~kill-clause~. I suppose it should kill the entire sentence:

: This is a test sentence, nothing to see here.^<EOB>

     Correct?

**** NOTE-TO-RÚDI Answers
1. Confirming that pasteboard-cut works as requested! Since there may be times when I don't want the new behavior, I reverted pasteboard-cut itself to its original behavior and created a new function, using your new code, called pasteboard-cut-and-capitalize.
2. Similarly, yes, let's add the capitalization functionality not to kill-line, but rather to my/kill-line-dwim. 
3. Answers for kill-clause below.

This is a test sentence^, nothing to see here. And then another.

     Caret marks the point. In this case, calling ~kill-clause~ results in:

This is a test sentence, ^nothing to see here. And then another.

     I.e. it only moves point. Please confirm that it should yield:

This is a test sentence^. And then another.

: Yes! Confirmed, that is what it should yield. 

     Now, going back to the current result of ~kill-clause~:

This is a test sentence, ^nothing to see here. And then another.

     If you now invoke ~kill-clause~, you'll have:

This is a test sentence, . ^And then another.

     This also seems silly. Again, it would seem reasonable to produce:

This is a test sentence^. And then another.

: Yes, exactly! That would be the desired behavior. However, the optimal point placement for that case would be this:
This is a test sentence. ^And then another.


     Finally, I found an edge case:

This is a test sentence, nothing to see here. ^And then another.<EOB>

     Where <EOB> marks the end of the buffer. In this case, nothing happens when you invoke ~kill-clause~. I suppose it should kill the entire sentence:

This is a test sentence, nothing to see here.^<EOB>

     Correct?

: Correct! Thanks for thoroughly thinking through these cases, much appreciated! 

**** NOTE-TO-RÚDI Comments about my edits to kill-clause-test-file.el 
What a brilliant approach, to create the test file! Here are some notes about my edits to the file.

Kill-clause should only kill one clause, which I think means it should only ever kill one comma, not two. So for the example below, it should leave the second comma in. I edited the desired output in kill-clause-test-file.el.

Input: We should consider^, for completeness, comma separated clauses. 
Your suggested output: We should consider^ comma separated clauses.
My desired output: We should consider^, comma separated clauses. 

Same for this one:

Input: We should consider,^ for completeness, comma separated clauses.
Your suggested output: We should consider^ comma separated clauses.
My desired output: We should consider,^ comma separated clauses. 

And this one:

Input: We should consider, ^for completeness, comma separated clauses.
Your suggested output: We should consider^ comma separated clauses.
My desired output: We should consider, ^comma separated clauses. 

With the example below, it should kill the question mark and leave the period. And the point should be before the period.

Input: And what about two consecutive sentences^? That's important too.
Your suggested output: And what about two consecutive sentences?^
My desired output: And what about two consecutive sentences^.

With the example below, I probably would never have the input you mentioned. I changed the syntax of the input to match the case I'm more likely to encounter. 

Your suggested input: ^Let's not forget parenthesis (those are extremely important!)
My more likely input: ^Let's not forget parenthesis (those are extremely important)! 
Output: (^Those are extremely important)! 

Same for this one:

Your suggested input: Let's not forget parenthesis ^(those are extremely important!) 
My more likely input: Let's not forget parenthesis ^(those are extremely important)! 
Output: Let's not forget parenthesis^! 

Thanks! 

**** NOTE-TO-RÚDI I reviewed kill-clause-test-file.el 
Thanks for the question about kill-clause-test-file.el. I reviewed the file and did find an error, which I corrected. The rest is as I intend it. I realize some of the desired behaviors may seem strange. But I'm crafting the tests with my specific editing habits in mind. I guess the main point is that when I use kill clause, usually I do so because I intend to write more words /within that clause/, not after it. In any case, the tests in the file will be an accurate gauge of the desired behavior. Thanks again! :-)

*** TODO [#A] add "capitalize first word of next sentence" to smart-period, smart-question-mark, and smart-exclamation mark
When I type a period, the next word after the period (i.e. the first word of the next sentence) should be automatically capitalized.

Currently, auto-capitalize-mode does this only if I type a new sentence after the period at that moment. If the next sentence is *already there*, and the first word of that sentence is uncapitalized, auto-capitalize mode does nothing. 

Therefore can you add something like the below to smart-period, smart-question-mark, and smart-exclamation mark? 

(save-excursion 
    (when (my/beginning-of-sentence-p)
      (capitalize-word 1))) 

Example:
: ^this is an existing sentence. 

Suppose the point is on the t in this and I type "Here's a new sentence. " 

Current output: 
: Here's a new sentence. ^this is an existing sentence. 

Desired output: 
: Here's a new sentence. ^This is an existing sentence. 

i.e. the period (or question mark or exclamation point) should trigger the capitalization of the first word in the next sentence. 

Thanks! 

*** TODO [#B] create an auto-capitalization-predicate-exceptions-list?
I'd like to create a plain-text list of words that are exceptions to auto-capitalization. So for e.g. if I type e.g. like I have in this sentence, I don't want the next word to be automatically capitalized. 

See my existing code: 

#+BEGIN_SRC emacs-lisp
(setq auto-capitalize-predicate
      (lambda () (not (looking-back "\\([Ee]\\.g\\|[Uu]\\.S\\|[Ii]\\.e\\|\\.\\.\\)\\.[^.]*" (- (point) 20)))))
#+END_SRC

This works. However, I'd like to be able to keep this list in a plain text format and add to it. The reason I'm asking is because I wanted to add the word "vs." to the list (e.g. "good vs. evil") but I couldn't get the regexp correct with all the slash escaping. It would be easier if the list looked something like this: 

#+BEGIN_SRC emacs-lisp
(setq *auto-capitalize-exceptions*
  (list "e.g." "i.e. " "vs." "..." "- [ ] ")) 
#+END_SRC

Thanks!

*** TODO [#C] a tweak to my/kill-sentence-dwim 
I created a test file my-kill-sentence-dwim-test-file.elt to illustrate input and desired output for an edge case I discovered. Thanks!
** 
*** TESTING [#B] a smart-space exception for org-mode tags

Example:
#+BEGIN_EXAMPLE
* Is this a viable^                                                   :slide: 
#+END_EXAMPLE

Let's say the point is on the carat and I type "business?"

Current output: 
#+BEGIN_EXAMPLE
* Is this a viable business ?slide: 
#+END_EXAMPLE

Desired output:
#+BEGIN_EXAMPLE
* Is this a viable business?^                                          :slide: 
#+END_EXAMPLE

*** NOTE-TO-RÚDI Question about spaces?
It works! Now, next question. Currently, when I type spaces between words in the heading, the space between the words and the tag gets collapsed. (Obviously it does, since I have <SPC> bound to jay/insert-space.) Is it easy to make it so that I can type spaces in the heading with collapsing the spaces between the heading and the tag? If it's too complicated, I can solve this problem on the "user side" by trying to remember to use M-SPC (insert-space) whenever I'm in an org-mode heading with a tag.

** TODO [#C] kill-ring-to-pasteboard
Can we create a function to push the contents of the kill ring to the pasteboard? Because some functions (e.g. gist-buffer) push output into the kill ring and I'd like to be able to access it from other OSX apps. Thanks!
