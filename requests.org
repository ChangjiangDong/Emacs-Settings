* file settings                                                     :ARCHIVE:
#+OPTIONS: f:t 
#+TODO: TODO PLEASE-TEST TESTING PLEASE-DEBUG | DONE
#+TODO: | NOTE-TO-JAY NOTE-TO-RUDI NOTE-TO-RÚDI
#+TITLE: #+TITLE: Jay Dixit's GNU Emacs setup 



* NOTE-TO-RÚDI priorities
If you could tackle the requests in the following order, that would be amazing:

1. requests.org: a simple search and replace function to add two styling tags in an email message after calling org-mime-htmlize
2. shared-functions.org: erika-send-email 
3. requests.org: smart-punctuation when there's already a correctly placed punctuation mark
4. requests.org: smart-punctuation when there's already a misplaced punctuation mark
5. kill-clause etc.

Thanks again!

* open requests 
** JavaScript 
*** TODO [#B] Capture to PDF and return to Chrome
Hi Rúdi,

Do you know JavaScript? If you're interested, I might have some very quick JavaScript questions. for example the below, which comes from here:
[[http://www.devontechnologies.com/download/extras-and-manuals.html][Install browser extensions and bookmarklets, and read the help files as PDFs or ebooks - DEVONtechnologies]]

I believe it's the bookmarklet labeled "Text"

#+BEGIN_SRC javascript
javascript:window.location='x-devonthink://createText?location='+encodeURIComponent(window.location)+'&text='+encodeURIComponent(getSelection()); 
#+END_SRC

It works correctly to capture text from Chrome and insert it into a tool called DevonThink. Ideally I'd like it to automatically return me to Chrome again when it's done instead of leaving me in DevonThink. Straightforward? Thanks! 

** Emacs 
*** TODO [#B] kill-line-and-capitalize [1/3]
Can you add something like this: 

(save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-word 1))))

to:

- [X] pasteboard-cut.
- [ ] kill-line. EDIT: I should have said my/kill-line-dwim 
- [ ] kill-clause.

Thanks! 

**** NOTE-TO-JAY Questions

     Regarding ~pasteboard-cut~, I think it's rather straightforward. Please give it a go.

     As for ~kill-line~, there's something I should clarify: this is a builtin command (comes with Emacs), so it's not something I can easily change. Except that Emacs Lisp has a nice little functionality called "advicing", which allows dynamically adding behaviour to functions without having access to their code. I could do this to ~kill-line~. However, this is usually not recommended, since it could mess up other functionalities that might depend on the default ~kill-line~ implementation. Anyway, since you have the ~my/kill-line-dwim~ function, isn't that the one you use?

     Finally, regarding ~kill-clause~, I added the requested functionality, but I realised the implementation has several probably undesired behaviours. For example:

: This is a test sentence^, nothing to see here. And then another.

     Caret marks the point. In this case, calling ~kill-clause~ results in:

: This is a test sentence, ^nothing to see here. And then another.

     I.e. it only moves point. Please confirm that it should yield:

: This is a test sentence^. And then another.

     Now, going back to the current result of ~kill-clause~:

: This is a test sentence, ^nothing to see here. And then another.

     If you now invoke ~kill-clause~, you'll have:

: This is a test sentence, . ^And then another.

     This also seems silly. Again, it would seem reasonable to produce:

: This is a test sentence^. And then another.

     Finally, I found an edge case:

: This is a test sentence, nothing to see here. ^And then another.<EOB>

     Where <EOB> marks the end of the buffer. In this case, nothing happens when you invoke ~kill-clause~. I suppose it should kill the entire sentence:

: This is a test sentence, nothing to see here.^<EOB>

     Correct?

**** NOTE-TO-RÚDI Answers
1. Confirming that pasteboard-cut works as requested! Since there may be times when I don't want the new behavior, I reverted pasteboard-cut itself to its original behavior and created a new function, using your new code, called pasteboard-cut-and-capitalize.
2. Similarly, yes, let's add the capitalization functionality not to kill-line, but rather to my/kill-line-dwim. 
3. Answers for kill-clause below.

This is a test sentence^, nothing to see here. And then another.

     Caret marks the point. In this case, calling ~kill-clause~ results in:

This is a test sentence, ^nothing to see here. And then another.

     I.e. it only moves point. Please confirm that it should yield:

This is a test sentence^. And then another.

: Yes! Confirmed, that is what it should yield. 

     Now, going back to the current result of ~kill-clause~:

This is a test sentence, ^nothing to see here. And then another.

     If you now invoke ~kill-clause~, you'll have:

This is a test sentence, . ^And then another.

     This also seems silly. Again, it would seem reasonable to produce:

This is a test sentence^. And then another.

: Yes, exactly! That would be the desired behavior. However, the optimal point placement for that case would be this:
This is a test sentence. ^And then another.


     Finally, I found an edge case:

This is a test sentence, nothing to see here. ^And then another.<EOB>

     Where <EOB> marks the end of the buffer. In this case, nothing happens when you invoke ~kill-clause~. I suppose it should kill the entire sentence:

This is a test sentence, nothing to see here.^<EOB>

     Correct?

: Correct! Thanks for thoroughly thinking through these cases, much appreciated! 

**** NOTE-TO-RÚDI Comments about my edits to kill-clause-test-file.el 
What a brilliant approach, to create the test file! Here are some notes about my edits to the file.

Kill-clause should only kill one clause, which I think means it should only ever kill one comma, not two. So for the example below, it should leave the second comma in. I edited the desired output in kill-clause-test-file.el.

Input: We should consider^, for completeness, comma separated clauses. 
Your suggested output: We should consider^ comma separated clauses.
My desired output: We should consider^, comma separated clauses. 

Same for this one:

Input: We should consider,^ for completeness, comma separated clauses.
Your suggested output: We should consider^ comma separated clauses.
My desired output: We should consider,^ comma separated clauses. 

And this one:

Input: We should consider, ^for completeness, comma separated clauses.
Your suggested output: We should consider^ comma separated clauses.
My desired output: We should consider, ^comma separated clauses. 

With the example below, it should kill the question mark and leave the period. And the point should be before the period.

Input: And what about two consecutive sentences^? That's important too.
Your suggested output: And what about two consecutive sentences?^
My desired output: And what about two consecutive sentences^.

With the example below, I probably would never have the input you mentioned. I changed the syntax of the input to match the case I'm more likely to encounter. 

Your suggested input: ^Let's not forget parenthesis (those are extremely important!)
My more likely input: ^Let's not forget parenthesis (those are extremely important)! 
Output: (^Those are extremely important)! 

Same for this one:

Your suggested input: Let's not forget parenthesis ^(those are extremely important!) 
My more likely input: Let's not forget parenthesis ^(those are extremely important)! 
Output: Let's not forget parenthesis^! 

Thanks! 

*** TODO [#A] smart-punctuation behaviors 
**** TODO [#A] smart-punctuation when there's already a misplaced punctuation mark?
Can we adjust the behavior of smart-punctuation somewhat for the edge case of dealing with a sentence that already has a misplaced punctuation mark (i.e. there's a space between the word and the punctuation mark.

Example:

: You might have a conscious intention to eat healthier , but you forget.

Say the point is on the comma. 

Current behavior: no effect.

Desired behavior: 
: You might have a conscious intention to eat healthier, but you forget.

**** TODO [#A] smart-punctuation when there's already a correctly placed punctuation mark
Example:

: You might have a conscious intention to eat healthier, but you forget.

Say the point is on the comma and I hit comma. Current behavior is to do nothing and keep the point on the comma. But this is counterintuitive, because if there is NO comma and I hit comma, it gives me a comma, my point is placed on the space AFTER the comma. I'd like to replicate this behavior---hitting comma gives consistent behavior regardless of whether there is an existing comma or not. 

Same thing if I hit ! or ? or . or ; and change the punctuation. Whenever I hit one of those punctuation marks, the point should be placed AFTER the punctuation mark, not stay on it. Thanks!! 

*** TODO [#C] create an auto-capitalization-predicate-exceptions-list?
I'd like to create a plain-text list of words that are exceptions to auto-capitalization. So for e.g. if I type e.g. like I have in this sentence, I don't want the next word to be automatically capitalized. 

See my existing code: 

#+BEGIN_SRC emacs-lisp
(setq auto-capitalize-predicate
      (lambda () (not (looking-back "\\([Ee]\\.g\\|[Uu]\\.S\\|[Ii]\\.e\\|\\.\\.\\)\\.[^.]*" (- (point) 20)))))
#+END_SRC

This works. However, I'd like to be able to keep this list in a plain text format and add to it. The reason I'm asking is because I wanted to add the word "vs." to the list (e.g. "good vs. evil") but I couldn't get the regexp correct with all the slash escaping. It would be easier if the list looked something like this: 

#+BEGIN_SRC emacs-lisp
(setq *auto-capitalize-exceptions*
  (list "e.g." "i.e. " "vs." "...")) 
#+END_SRC

Thanks!

*** TODO [#A] a simple search and replace function to add two styling tags in an email message after calling org-mime-htmlize
When composing email in Emacs, I use org-mime, which is available through org-plus-contrib, to convert my email to HTML. After composing an email, I call a function called org-mime-htmlize, and the result is a message-mode buffer that looks something like this:

#+BEGIN_EXAMPLE
To: Jay Dixit <sunjaydixit@gmail.com>
Subject: test of org-mime
From: Jay Dixit <dixit@aya.yale.edu>
--text follows this line--
<#multipart type=alternative><#part type=text/plain>:PROPERTIES:
:SENT-ON:  Thu Jul  9 01:51:18 2015
:TO:       Jay Dixit <sunjaydixit@gmail.com>
:END:
Hello.

There's this:

- one
- two
- three

And this:
1. one
2. two
3. three

Warm regards,
Jay Dixit

---
Jay Dixit 
(646) 355-8001 
[[http://jaydixit.com/][jaydixit.com]] 
<#multipart type=related><#part type=text/html><p>
Hello.<br  />
</p>

<p>
There&rsquo;s this:<br  />
</p>

<ul class="org-ul">
<li>one<br  />
</li>
<li>two<br  />
</li>
<li>three<br  />
</li>
</ul>

<p>
And this:<br  />
</p>
<ol class="org-ol">
<li>one<br  />
</li>
<li>two<br  />
</li>
<li>three<br  />
</li>
</ol>

<p>
Warm regards,<br  />
Jay Dixit<br  />
</p>

<p>
&#x2014;<br  />
Jay Dixit<br  />
(646) 355-8001<br  />
<a href="http://jaydixit.com/">jaydixit.com</a> <br  />
</p>
<#/multipart>
<#/multipart> 
#+END_EXAMPLE

I'd like a function I can call after I call org-mime-htmlize that will add HTML styling tags at the beginning and end of the HTML part of the message. Specifically, I'd like to: 
1. add ~<div style="font-family:Georgia,serif">~ right after ~<#multipart type=related><#part type=text/html>~
2. add a closing ~</div>~ right before ~<#/multipart><#/multipart>~

So for the example above, the desired output would be: 
#+BEGIN_EXAMPLE
To: Jay Dixit <sunjaydixit@gmail.com>
Subject: test of org-mime
From: Jay Dixit <dixit@aya.yale.edu>
--text follows this line--
<#multipart type=alternative><#part type=text/plain>:PROPERTIES:
:SENT-ON:  Thu Jul  9 01:51:18 2015
:TO:       Jay Dixit <sunjaydixit@gmail.com>
:END:
Hello.

There's this:

- one
- two
- three

And this:
1. one
2. two
3. three

Warm regards,
Jay Dixit

---
Jay Dixit 
(646) 355-8001 
[[http://jaydixit.com/][jaydixit.com]] 
<#multipart type=related><#part type=text/html>
<div style="font-family:Georgia,serif"> 
<p>
Hello.<br  />
</p>

<p>
There&rsquo;s this:<br  />
</p>

<ul class="org-ul">
<li>one<br  />
</li>
<li>two<br  />
</li>
<li>three<br  />
</li>
</ul>

<p>
And this:<br  />
</p>
<ol class="org-ol">
<li>one<br  />
</li>
<li>two<br  />
</li>
<li>three<br  />
</li>
</ol>

<p>
Warm regards,<br  />
Jay Dixit<br  />
</p>

<p>
&#x2014;<br  />
Jay Dixit<br  />
(646) 355-8001<br  />
<a href="http://jaydixit.com/">jaydixit.com</a> <br  />
</p>
</div>
<#/multipart>
<#/multipart> 
#+END_EXAMPLE

Does that make sense? Thanks! 
