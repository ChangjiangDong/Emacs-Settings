* completed requests                                     :ARCHIVE:
#+OPTIONS: f:t 


** DONE [#A] make kill-word-correctly-and-capitalize count a line break as a word 
Rúdi, 

Before I asked you to make kill-word-correctly kill not only words one at a time, but also punctuation one at a time, such that given this... 

#+BEGIN_QUOTE
The sea. Ocean. 

I still remember that day.
#+END_QUOTE 

...and supposing the mark was on the T in The, invoking kill-word-correctly twice would kill "The" and "sea" but leave in period, and invoking it a third time would kind the period as well. And you implemented this perfectly. 

Now I’d like to make kill-word-correctly and kill-word-correctly-and-capitalize recognize line breaks in the same way, counting each line break as a word. 

In the above, let's say the point is on the "O" in "Ocean". And let's say I invoke kill-word-correctly-and-capitalize 3 times. 

Current output: 

#+BEGIN_QUOTE
The sea. still remember that day.
#+END_QUOTE 

Desired output: 

#+BEGIN_QUOTE
The sea. 
I still remember that day.
#+END_QUOTE 

Thanks!

** DONE [#A] an edge case for kill-word-correctly-and-capitalize

#+BEGIN_QUOTE
He's a science writer specializing in psychology (NYT, Wired, Psychology Today). 
#+END_QUOTE

Suppose the point is on the "is" in "specializing" and my goal is to invoke kill-word-correctly-and-capitalize 3 times in order to kill the phrase "specializing in psychology".

Current output: 
He's a science writer(NYT, Wired, Psychology Today). 

Desired output: 
He's a science writer specializing in psychology (NYT, Wired, Psychology Today). 

Note that the same output is created if I highlight the phrase "specializing in psychology" and hit my/delete-backward.

Can we fix for both kill-word-correctly-and-capitalize and my/delete-backward? Thanks!

*** DONE Try it now

    The problem was with ~my/fix-space~, which was deleting spaces before punctuation indiscriminately. Now it only deletes spaces before the characters: .,:;!?»)-. Note that this will affect many other functions, sice ~my/fix-space~ is called in a number of places. I think the result will nonetheless be the desired one.


* kill clause

I want to use this to create a function to kill-clause (not kill sentence).


** DONE! :-) There's no doubt a better way to do this than the way I did it, which is to redefine sentence-end-base, kill the "sentence," then redefining sentence-end-base back again. :rudi:

#+BEGIN_SRC emacs-lisp
;;; old version; try the one below and replace it if it is working as intended.
;; (defun kill-clause ()
;;   (interactive) 
;; (expand-abbrev)
;;               (when (string-match "^\\[" sentence-end-base)
;;     (progn 
;;               (setq sentence-end-base
;;                       (replace-match "--\\|[,;.?!…/" t t sentence-end-base)))
;; (my/kill-sentence-dwim)
;; (setq sentence-end-base "[.?!…][]\"'”)}]*")))
#+END_SRC

*** DONE! :-) DONE Request for clarification                     :followup:

: Please clarify what you intend to do with this command.  From what I gather, you intend this function to do exactly what my/kill-sentence-dwim, as if "--", "," and ";" also marked the end of a sentence. If that is the case, then why do you also add the characters "?!…" to sentence-end-base, given that they (presumably) were already there?

I may have made a mistake. My intention is that: 

1. kill-clause should kill text up to -- --- , ; ! ? ... or . 
2. my/kill-sentence-dwim should kill text up to ! ? ... or .

Otherwise, yes, it should work exactly like my/kill-sentence-dwim. Thank you! 

*** DONE! :-) Try this

    Well, it is a pretty clever way of doing it... you're thinking like a true hacker. :) However, ~setq~'ing like in the Wild West is dangerous.

: Haha! Thank you!

    ~let~ will be your friend here.

#+BEGIN_SRC emacs-lisp
;; Identify the end of sentences globally.
(setq sentence-end-base "[.?!…][]\"'”)}]*")

;; Clauses are like sentences, but with some additional end markers. Rebind `sentence-end-base' locally to get that effect.
(defun kill-clause ()
  (interactive) 
  (expand-abbrev)
  (let ((sentence-end-base "--\\|[,;.?!…][]\"'”)}]*"))
    (my/kill-sentence-dwim)))
#+END_SRC

: Perfect!

** DONE [#A] kill word correctly and capitalize 
Rúdi,

Note that I added capitalize-word and left-word to the above. My goal is to instruct Emacs to check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly.

What I did above works, but it breaks when it deals with punctuation. Example #1:

: My fascination began when I was four years old. For some reason, I was immediately intrigued. 

Let's say the point is on the F in For, and my goal is to invoke kill-word-correctly-and-capitalize 4 times, deleting those 3 words plus the comma to wind up with this:

: My fascination began when I was four years old. I was immediately intrigued. 

As you can see, the comma handling gets messed up. 

Example #2:

#+BEGIN_QUOTE
I didn't hurt myself. Meanwhile, 

I still remember that day.
#+END_QUOTE

Let's say the point is on the M in Meanwhile, and my goal is to invoke kill-word-correctly-and-capitalize twice, deleting the word plus the comma to wind up with this: 

#+BEGIN_QUOTE
I didn't hurt myself. 

I still remember that day.
#+END_QUOTE

Example #3:
: This above all, to thine own self be true. 

Say the point is on the T in This and my goal is to invoke kill-word-correctly-and-capitalize 4 times so that the first word is "To."

Your implementation of kill-word-correctly works properly in all the examples above. My goal is to get kill-word-correctly-and-capitalize to deal with such cases correctly also. Is it possible to do this, or does the invocation of left-word mess things up? Thanks! 

** DONE [#B] Create an exception to smart-punctuation 
so it doesn't invoke when it's at the beginning of a line. I need to be able to write sentences like this:

#+BEGIN_EXAMPLE

- bullet points like this 
- or this 

...and ellipses at the beginning of lines like this.

#+END_EXAMPLE
** DONE no space between end of word and punctuation mark 
Can make it so that when I invoke punctuation, it removes any space between the word and the punctuation?

#+BEGIN_EXAMPLE
The night is dark But the day is bright. 
#+END_EXAMPLE

Such that, for instance, if the point is on the B in But, and I hit "." Emacs will automatically remove the unwanted space, so that I get this: 

: The night is dark. But the day is bright. 

...instead of this:

: The night is dark .But the day is bright. 

I presume that changing this will have the same effect on , ; : ! and ?

Thanks! 

*** DONE Try it

    I have added the functionality you requested, but I'm not sure about the semicolon and colon; I added a ~smart-~ function for them too, but one that is not so smart: i.e. does not replace the previous punctuation mark; it only tries to fix the spaces around). However, it does not seem reasonable to write ".:", ".;", ":.", etc. If you wish the semi-colon and colon to have the same behaviour as the other punctuation marks (remove the previous mark), you can just remove the "t" in the call to ~smart-punctuation~. 

: Looks great! Yes, I think I'd like ; and : to work the same way. What's the argument against this? Is there some reason it might be helpful for them to operate differently? 

*** DONE [#A] a few requests re the above
1. When I'm typing a sentence and I put a punctuation mark like "." at the end of it, I now automatically get a SPACE after the "."

I am used to hitting the space key after a punctuation mark (and I will need to keep doing so in all other applications, so I'd like Emacs to /not/ insert the space automatically when I'm typing sentences. To do this, I commented out the my/fix-space at the end of smart-punctuation. But now when there's something like this: 

: This. ^

...and if the point is on the ^ above, and I hit "?" Emacs then removes the existing space after cycling to a question mark. 

I'd like smart-punctuation to behave differently based on whether I'm inserting punctuation after a word (no automatic insertion of space) or after an existing punctuation mark in order to cycle it (in which case I’d like to call my/fix-space to make sure there's a space after the punctuation mark).

2. I will sometimes need to write a parenthesis followed by a period, like this: 

#+BEGIN_EXAMPLE
Alice had nothing to do (once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it). ^
#+END_EXAMPLE

To enable this, I tried adding ")." to smart-punctuation-exceptions, which seems to work... but now if I go to point ^ above and hit "?" Emacs then clobbers the parenthesis (not desired) in addition to cycling the period. Can we fix this? 

3. Finally, can we change the behavior of smart-period such that if I forget about the cycling between period and ellipses, and I just type a word followed by hitting period 3 times, it successfully inserts an ellipsis? Maybe the best way to do this would be to just turn off the cycling between period and ellipsis for now. It's a good idea, but I want to be able to type:
<KB>words... </KB>
and get an ellipsis. Thanks! 

** DONE request: smart punctuation insertion 
Rúdi, can you add a line to the functions below that will automatically delete existing punctuation when one of these smart-punctuation functions gets called?

I'll give you an example of what I mean. Consider this sentence:

: The rain in Spain falls mainly on the plains! 

Let's say the point is on the space after the ! at the end of the sentence.

If I then hit ? (which calls smart-question-mark), Emacs should DELETE the existing ! and then replace it with a ? (and then put a space after it).

The logic of this is that I will NEVER be trying to type anything like:

- Hello!?
- Hello.!
- Hello?.
- Hello,.
- Hello.,

In other words, if the point is after a ; : , ! ? or . and then I hit a punctuation mark, it's almost certain that I am doing this because I wish to CHANGE the punctuation and not ADD one punctuation mark after another. 

*** Exceptions
1. I will often want to type three dots like so:
: To be continued...
2. or occasionally a question mark followed by an exclamation point like so:
: What the hell?!
3. I still need to be able to indicate em dashes---that is, three hyphens in a row.

Is this straightforward to implement, or do the exceptions create a lot of complications? Exception #2 is very rare, so if it creates problems we can forget about it. Really #1 and #3 are the important ones. 
* open requests
** TODO [#C] JavaScript?
Hi Rúdi,

Do you know JavaScript? If you're interested, I might have some very quick JavaScript questions. for example the below, which comes from here:
[[http://www.devontechnologies.com/download/extras-and-manuals.html][Install browser extensions and bookmarklets, and read the help files as PDFs or ebooks - DEVONtechnologies]]

I believe it's the bookmarklet labeled "Text"

#+BEGIN_SRC javascript
javascript:window.location='x-devonthink://createText?location='+encodeURIComponent(window.location)+'&text='+encodeURIComponent(getSelection()); 
#+END_SRC

It works correctly to capture text from Chrome and insert it into a tool called DevonThink. Ideally I'd like it to automatically return me to Chrome again when it's done instead of leaving me in DevonThink. Straightforward? Thanks! 

