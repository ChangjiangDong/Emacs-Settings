* file settings                                                     :ARCHIVE:
#+OPTIONS: f:t 
#+TODO: TODO PLEASE-TEST TESTING | DONE 
#+TODO: NOTE-TO-JAY NOTE-TO-RUDY
#+TITLE: #+TITLE: Jay Dixit's GNU Emacs setup 



* completed requests                                     :ARCHIVE:

** DONE [#A] org-return-follows-link
Another edge case: hitting return when on an org-mode link (see variable org-return-follows-link). With smart-return, return no longer follows link. Can we make it so this functionality is preserved with smart-return? Thanks!



* DONE [#A] disable cycling between hyphen and ellipsis?
Can you disable cycling between hyphen and ellipsis? It's a great idea but I realize there are times when I want to type a long line of 30 periods in a row (without using the number prefix). Should I just add ".........................." to smart-punctuation-exceptions? Thanks!

** NOTE-TO-JAY Answer

   Yes, adding that as an exception should work. 


* DONE [#C] cycle punctuation 

create a function cycle-punctuation. Kind of like cycle-hyphenation, except that invoking cycle-punctuation would change the punctuation at the end of a sentence between "." "!" "?" and back again. Such that given the sentence...

: The rain in Spain falls mainly on the plains. 

...and assuming the point was on the "T" or the "." or anywhere in between, invoking cycle-punctuation would leave the point wherever it was and cycle between these three states:

: The rain in Spain falls mainly on the plains. 
: The rain in Spain falls mainly on the plains? 
: The rain in Spain falls mainly on the plains! 

In fact, let's create a cycle-punctuation function also, even if the smart-punctuation functions above are also feasible. Here's some code that might help. 
http://ergoemacs.org/emacs/elisp_change_space-hyphen_underscore.html 

Thanks!!

(define-key org-mode-map (kbd "M-.") 'cycle-punctuation)

** NOTE-TO-JAY Implementation & question

   What should happen when the sentence doesn't end with any of these markers? My suggested implementation (below) does nothing.
** 
** NOTE-TO-RUDI Answer
Perfect.


* DONE [#A] an edge case for kill-clause
Can we make kill-clause count "(" as punctuation? 

Consider:

: So she was considering in her own mind (as well as she could, for the hot day made her feel very sleepy and stupid).

Suppose the point is on the "S" in "So" and I invoke kill-clause.

Current output:
:, for the hot day made her feel very sleepy and stupid).

Desired output: 
: (as well as she could, for the hot day made her feel very sleepy and stupid).

I tried adding "(" to ~(let ((sentence-end-base~ in kill-clause, but it doesn't seem to have worked. Thanks!

** NOTE-TO-JAY Answer

   Hm, the hacking fell short. You see, ~my/kill-sentence-dwim~ always expects spaces between sentences, and since there is no space after '(', it could never catch it. We'll have to refactor it.

   I added a new version, though I can already think of some edge cases.

: Killing causes doesn't work e.g. on this sentence.

   If you call ~kill-clause~ with point on 'K', it will kill until the ' in doesn't. If point is on 'w' from 'work', it will kill until the 'e' in 'e.g.'. I don't suppose this is desired behaviour. Do you confirm? Should I handle it?

** NOTE-TO-RÚDI Yes please. 
Yes, if you could handle this, that would be great. The two cases you mention above are frequent cases for me, so handling them is high-priority. 

** NOTE-TO-JAY OK, but...

   The last period in 'e.g.' is not so easy to handle, especially since you don't use double spaces after sentences. Emacs' sentence and fill functionalities (at least) use ~sentence-end-double-space~ to determine where sentences end -- if the variable is t, a double space is required after the punctuation mark, otherwise only one. This serves exactly the purpose of solving this problem. This is taken from the [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Sentences.html][Emacs Manual]]:

#+BEGIN_QUOTE
The sentence commands assume that you follow the American typist’s convention of putting two spaces at the end of a sentence. That is, a sentence ends wherever there is a ‘.’, ‘?’ or ‘!’ followed by the end of a line or two spaces, with any number of ‘)’, ‘]’, ‘'’, or ‘"’ characters allowed in between. A sentence also begins or ends wherever a paragraph begins or ends. It is useful to follow this convention, because it allows the Emacs sentence commands to distinguish between periods that end a sentence and periods that indicate abbreviations.
#+END_QUOTE

   So, in the example I gave above:

: Killing causes doesn't work e.g. on this sentence.

   And if point in on 'K', and after fixing the problem with ', killing the clause would nonetheless yield:

: on this sentence.

   The same happens if you ~kill-sentence~, BTW.
** NOTE-TO-RÚDI Answer
Got it. In that case, let's not worry about the case of "e.g." As long as the "don't" case works, which it seems to, I am satisfied. 


* DONE [#B] cycle-hyphenation for multiple words
Can we modify cycle-hyphenation so that it can successfully hyphenate more than 2 words? 

: He is the editor in chief of the magazine. 

Suppose the point is on the "e" in "editor" and I invoke cycle-hyphenation 2 times in a row. 

Current output:
: He is the editor-in chief-of the magazine. 

Desired output:
: He is the editor-in-chief of the magazine. 

Can we modify cycle-hyphenation to deal with this special case? Thanks! :-)

** NOTE-TO-JAY Answer

   OK, but I changed the semantics of the command slightly. Take your example:

: He is the editor in chief of the magazine. 

   Suppose the point is NOT on the 'e', but on the SPACE just before it. With the previous version, you'd get:

: He is the editor-in chief of the magazine. 

   As desired. With the new version, you get:

: He is the-editor in chief of the magazine. 

   Which is not desired. So: always ~cycle-hyphenise~ when point is ON or AFTER the beginning of the word you wish to join with the following. Same goes with the cycling back from - to space.

** NOTE-TO-JAY Answer
Got it. Thanks!! 


* DONE [#A] isearch contents of pasteboard
can we add a function to search within the current buffer, using the contents of the OS X system pasteboard as the search term? See pasteboard-paste above.

i.e. so this way I don't have to do isearch-forward and THEN also pasteboard-paste to paste in the search term I want. if for example I've already copied the search term from another buffer or from Chrome, I want to be able to search for it with one keystroke. Thanks!

** NOTE-TO-JAY Try this

#+BEGIN_SRC emacs-lisp
(defun pasteboard-search-in-current-buffer ()
  (interactive)
  (let ((search-term
         (with-temp-buffer
           (pasteboard-paste)
           (buffer-string))))
    (search-forward search-term)))

(define-key key-minor-mode-map (kbd "s-F") 'pasteboard-search-in-current-buffer) 
#+END_SRC

** NOTE-TO-RÚDI Seems to work. Thank you! 



* DONE [#B] self insert space 

Can we create a command to self-insert space? Which I'll bind to M-SPC in case I ever need to insert a space the old-fashioned way without invoking all this fancy DWIM stuff. Thanks. :-)

** NOTE-TO-JAY Try this

    Not sure if this is what you want -- and it might have undesired consequences -- but this basically switches the SPC and M-SPC events:

# #+BEGIN_SRC emacs-lisp
(define-key key-translation-map (kbd "SPC") (kbd "M-SPC"))
(define-key key-translation-map (kbd "M-SPC") (kbd "SPC"))
# #+END_SRC 

    If SPC is bound to ~self-insert-command~, and M-SPC to ~jay/insert-space~ or any other function, then this will switch the invoked commands; meaning, if you hit SPC, it will be like hitting M-SPC, and M-SPC will be like hitting SPC.

    I'll leave it commented, since I don't know if this is really what you want. 
** NOTE-TO-RUDI dealing with the minibuffer 
seems to work! thank you!

Update: I ran into problems in the minibuffer. Seems like the key translation switcheroo doesn't work in the minibuffer? When I call ~helm-M-x~ and then enter a word followed by a space (e.g. "org agenda") it reads the space as M-SPC and I get an error. 

I tried this... 

(define-key minibuffer-local-map (kbd "<M-SPC>") 'jay/insert-space) 
(global-set-key (kbd "<M-SPC>") 'jay/insert-space) 

...but it didn't fix the problem.

Again, the goal is to have a way (ideally through M-SPC) to add an arbitrary number of spaces, ignoring the my/fix-space constraints we've created.

*** NOTE-TO-JAY 

    I see. Well, that's the kind of "undesired consequences" I imagined could happen indeed.

    Forget about the switcheroo. Here, try this:

#+BEGIN_SRC emacs-lisp
(defun insert-space ()
  (interactive)
  (let ((last-command-event ? ))
    (call-interactively 'self-insert-command)))

(global-set-key (kbd "M-SPC") 'insert-space)
#+END_SRC 


* DONE [#B] list of abbrevs to be expanded to TextExpander as case-sensitive 
can we implement a way for me to add words to a list of export-to-TextExpander exceptions i.e. words that are >1char that should be exported as case-sensitive, i.e. abbrevationMode 0

e.g. 
(setq textexpander-export-as-case-sensitive-list 
  ("id" "wed" "im" "sd" "uk" "US" "OS" "CK")) 

** NOTE-TO-JAY Try it

   I added it to export-to-text-expander.el.

** DONE [#A] make kill-word-correctly-and-capitalize count a line break as a word 
Rúdi, 

Before I asked you to make kill-word-correctly kill not only words one at a time, but also punctuation one at a time, such that given this... 

#+BEGIN_QUOTE
The sea. Ocean. 

I still remember that day.
#+END_QUOTE 

...and supposing the point was on the T in The, invoking kill-word-correctly twice would kill "The" and "sea" but leave in period, and invoking it a third time would kind the period as well. And you implemented this perfectly. 

Now I’d like to make kill-word-correctly and kill-word-correctly-and-capitalize recognize line breaks in the same way, counting each line break as a word. 

In the above, let's say the point is on the "O" in "Ocean". And let's say I invoke kill-word-correctly-and-capitalize 3 times. 

Current output: 

#+BEGIN_QUOTE
The sea. still remember that day.
#+END_QUOTE 

Desired output: 

#+BEGIN_QUOTE
The sea. 
I still remember that day.
#+END_QUOTE 

Thanks!

** DONE [#A] an edge case for kill-word-correctly-and-capitalize

#+BEGIN_QUOTE
He's a science writer specializing in psychology (NYT, Wired, Psychology Today). 
#+END_QUOTE

Suppose the point is on the "is" in "specializing" and my goal is to invoke kill-word-correctly-and-capitalize 3 times in order to kill the phrase "specializing in psychology".

Current output: 
He's a science writer(NYT, Wired, Psychology Today). 

Desired output: 
He's a science writer specializing in psychology (NYT, Wired, Psychology Today). 

Note that the same output is created if I highlight the phrase "specializing in psychology" and hit my/delete-backward.

Can we fix for both kill-word-correctly-and-capitalize and my/delete-backward? Thanks!

*** DONE Try it now

    The problem was with ~my/fix-space~, which was deleting spaces before punctuation indiscriminately. Now it only deletes spaces before the characters: .,:;!?»)-. Note that this will affect many other functions, sice ~my/fix-space~ is called in a number of places. I think the result will nonetheless be the desired one.


** kill clause

I want to use this to create a function to kill-clause (not kill sentence).


** DONE! :-) There's no doubt a better way to do this than the way I did it, which is to redefine sentence-end-base, kill the "sentence," then redefining sentence-end-base back again. :rudi:

#+BEGIN_SRC emacs-lisp
;;; old version; try the one below and replace it if it is working as intended.
;; (defun kill-clause ()
;;   (interactive) 
;; (expand-abbrev)
;;               (when (string-match "^\\[" sentence-end-base)
;;     (progn 
;;               (setq sentence-end-base
;;                       (replace-match "--\\|[,;.?!…/" t t sentence-end-base)))
;; (my/kill-sentence-dwim)
;; (setq sentence-end-base "[.?!…][]\"'”)}]*")))
#+END_SRC

*** DONE! :-) DONE Request for clarification                     :followup:

: Please clarify what you intend to do with this command.  From what I gather, you intend this function to do exactly what my/kill-sentence-dwim, as if "--", "," and ";" also marked the end of a sentence. If that is the case, then why do you also add the characters "?!…" to sentence-end-base, given that they (presumably) were already there?

I may have made a mistake. My intention is that: 

1. kill-clause should kill text up to -- --- , ; ! ? ... or . 
2. my/kill-sentence-dwim should kill text up to ! ? ... or .

Otherwise, yes, it should work exactly like my/kill-sentence-dwim. Thank you! 

*** DONE! :-) Try this

    Well, it is a pretty clever way of doing it... you're thinking like a true hacker. :) However, ~setq~'ing like in the Wild West is dangerous.

: Haha! Thank you!

    ~let~ will be your friend here.

#+BEGIN_SRC emacs-lisp
;; Identify the end of sentences globally.
(setq sentence-end-base "[.?!…][]\"'”)}]*")

;; Clauses are like sentences, but with some additional end markers. Rebind `sentence-end-base' locally to get that effect.
(defun kill-clause ()
  (interactive) 
  (expand-abbrev)
  (let ((sentence-end-base "--\\|[,;.?!…][]\"'”)}]*"))
    (my/kill-sentence-dwim)))
#+END_SRC

: Perfect!

** DONE [#A] kill word correctly and capitalize 
Rúdi,

Note that I added capitalize-word and left-word to the above. My goal is to instruct Emacs to check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly.

What I did above works, but it breaks when it deals with punctuation. Example #1:

: My fascination began when I was four years old. For some reason, I was immediately intrigued. 

Let's say the point is on the F in For, and my goal is to invoke kill-word-correctly-and-capitalize 4 times, deleting those 3 words plus the comma to wind up with this:

: My fascination began when I was four years old. I was immediately intrigued. 

As you can see, the comma handling gets messed up. 

Example #2:

#+BEGIN_QUOTE
I didn't hurt myself. Meanwhile, 

I still remember that day.
#+END_QUOTE

Let's say the point is on the M in Meanwhile, and my goal is to invoke kill-word-correctly-and-capitalize twice, deleting the word plus the comma to wind up with this: 

#+BEGIN_QUOTE
I didn't hurt myself. 

I still remember that day.
#+END_QUOTE

Example #3:
: This above all, to thine own self be true. 

Say the point is on the T in This and my goal is to invoke kill-word-correctly-and-capitalize 4 times so that the first word is "To."

Your implementation of kill-word-correctly works properly in all the examples above. My goal is to get kill-word-correctly-and-capitalize to deal with such cases correctly also. Is it possible to do this, or does the invocation of left-word mess things up? Thanks! 

** DONE [#B] Create an exception to smart-punctuation 
so it doesn't invoke when it's at the beginning of a line. I need to be able to write sentences like this:

#+BEGIN_EXAMPLE

- bullet points like this 
- or this 

...and ellipses at the beginning of lines like this.

#+END_EXAMPLE
** DONE no space between end of word and punctuation mark 
Can make it so that when I invoke punctuation, it removes any space between the word and the punctuation?

#+BEGIN_EXAMPLE
The night is dark But the day is bright. 
#+END_EXAMPLE

Such that, for instance, if the point is on the B in But, and I hit "." Emacs will automatically remove the unwanted space, so that I get this: 

: The night is dark. But the day is bright. 

...instead of this:

: The night is dark .But the day is bright. 

I presume that changing this will have the same effect on , ; : ! and ?

Thanks! 

*** DONE Try it

    I have added the functionality you requested, but I'm not sure about the semicolon and colon; I added a ~smart-~ function for them too, but one that is not so smart: i.e. does not replace the previous punctuation mark; it only tries to fix the spaces around). However, it does not seem reasonable to write ".:", ".;", ":.", etc. If you wish the semi-colon and colon to have the same behaviour as the other punctuation marks (remove the previous mark), you can just remove the "t" in the call to ~smart-punctuation~. 

: Looks great! Yes, I think I'd like ; and : to work the same way. What's the argument against this? Is there some reason it might be helpful for them to operate differently? 

*** DONE [#A] a few requests re the above
1. When I'm typing a sentence and I put a punctuation mark like "." at the end of it, I now automatically get a SPACE after the "."

I am used to hitting the space key after a punctuation mark (and I will need to keep doing so in all other applications, so I'd like Emacs to /not/ insert the space automatically when I'm typing sentences. To do this, I commented out the my/fix-space at the end of smart-punctuation. But now when there's something like this: 

: This. ^

...and if the point is on the ^ above, and I hit "?" Emacs then removes the existing space after cycling to a question mark. 

I'd like smart-punctuation to behave differently based on whether I'm inserting punctuation after a word (no automatic insertion of space) or after an existing punctuation mark in order to cycle it (in which case I’d like to call my/fix-space to make sure there's a space after the punctuation mark).

2. I will sometimes need to write a parenthesis followed by a period, like this: 

#+BEGIN_EXAMPLE
Alice had nothing to do (once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it). ^
#+END_EXAMPLE

To enable this, I tried adding ")." to smart-punctuation-exceptions, which seems to work... but now if I go to point ^ above and hit "?" Emacs then clobbers the parenthesis (not desired) in addition to cycling the period. Can we fix this? 

3. Finally, can we change the behavior of smart-period such that if I forget about the cycling between period and ellipses, and I just type a word followed by hitting period 3 times, it successfully inserts an ellipsis? Maybe the best way to do this would be to just turn off the cycling between period and ellipsis for now. It's a good idea, but I want to be able to type:
<KB>words... </KB>
and get an ellipsis. Thanks! 

** DONE request: smart punctuation insertion 
Rúdi, can you add a line to the functions below that will automatically delete existing punctuation when one of these smart-punctuation functions gets called?

I'll give you an example of what I mean. Consider this sentence:

: The rain in Spain falls mainly on the plains! 

Let's say the point is on the space after the ! at the end of the sentence.

If I then hit ? (which calls smart-question-mark), Emacs should DELETE the existing ! and then replace it with a ? (and then put a space after it).

The logic of this is that I will NEVER be trying to type anything like:

- Hello!?
- Hello.!
- Hello?.
- Hello,.
- Hello.,

In other words, if the point is after a ; : , ! ? or . and then I hit a punctuation mark, it's almost certain that I am doing this because I wish to CHANGE the punctuation and not ADD one punctuation mark after another. 

*** Exceptions
1. I will often want to type three dots like so:
: To be continued...
2. or occasionally a question mark followed by an exclamation point like so:
: What the hell?!
3. I still need to be able to indicate em dashes---that is, three hyphens in a row.

Is this straightforward to implement, or do the exceptions create a lot of complications? Exception #2 is very rare, so if it creates problems we can forget about it. Really #1 and #3 are the important ones. 
* open requests
** TODO [#C] JavaScript?
Hi Rúdi,

Do you know JavaScript? If you're interested, I might have some very quick JavaScript questions. for example the below, which comes from here:
[[http://www.devontechnologies.com/download/extras-and-manuals.html][Install browser extensions and bookmarklets, and read the help files as PDFs or ebooks - DEVONtechnologies]]

I believe it's the bookmarklet labeled "Text"

#+BEGIN_SRC javascript
javascript:window.location='x-devonthink://createText?location='+encodeURIComponent(window.location)+'&text='+encodeURIComponent(getSelection()); 
#+END_SRC

It works correctly to capture text from Chrome and insert it into a tool called DevonThink. Ideally I'd like it to automatically return me to Chrome again when it's done instead of leaving me in DevonThink. Straightforward? Thanks! 
** TODO sense when I'm in a plain text list 
RET (translated from <return>) 

RET (translated from <return>) runs the command (lambda nil
(interactive) (if (region-active-p) (delete-region (region-beginning)
(region-end)) (call-interactively (quote org-return)))), which is an
interactive Lisp function.

It is bound to RET. 

- item 1<RET>

* TODO line of periods


Alice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do: once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it! "And what is the use of a book," thought Alice, "without pictures or conversations?" 

So she was considering in her own mind (as well as she could, for the hot day made her feel very sleepy and stupid), whether the pleasure of making a daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly a White Rabbit with pink eyes ran close by her.

There was nothing so very remarkable in that; nor did Alice think it so very much out of the way to hear the Rabbit say to itself, "Oh dear! Oh dear! I shall be late!" (When she thought it over afterwards, it occurred to her that she ought to have wondered at this, but at the time it all seemed quite natural.) But when the Rabbit actually took a watch out of its waistcoat-pocket, and looked at it, and then hurried on, Alice started to her feet, for it flashed across her mind that she had never before seen a rabbit with either a waistcoat-pocket, or a watch to take out of it. 
