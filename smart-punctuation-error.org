* in the examples below:
1. Place a period after "swans"
2. Place a comma after "run from them" 

* Now rate how willing you were to have these sensations/feelings without acting on them, i.e. trying to manage them, get rid of them, suppress them, run from them (0 to 8):
5 (pretty willing to accept)

Geneva... swans

* error messages
** Geneva... swans error debug buffers 1 - 4

   #+BEGIN_SRC emacs-lisp
point: 318
before spaces: 318
whole match: ""
spaces before: ""
pre-existing punct: "" 

point: 318
before spaces: 318
whole match: #(" " 0 1 (fontified t line-prefix #("  " 0 2 (face org-indent)) wrap-prefix #("  " 0 2 (face org-indent))))
spaces before: #(" " 0 1 (fontified t line-prefix #("  " 0 2 (face org-indent)) wrap-prefix #("  " 0 2 (face org-indent))))
pre-existing punct: ""

at heading
text: Genva.
narrowing to: 500 506
point: 506
before spaces: 505
whole match: #("." 0 1 (fontified t line-prefix #("*" 0 1 (face org-hide)) wrap-prefix #("    " 0 4 (face org-indent)) face org-level-2))
spaces before: ""
pre-existing punct: #("." 0 1 (fontified t line-prefix #("*" 0 1 (face org-hide)) wrap-prefix #("    " 0 4 (face org-indent)) face org-level-2))

at heading
text: Genva..
narrowing to: 500 507
point: 507
before spaces: 505
whole match: #(".." 0 2 (fontified t line-prefix #("*" 0 1 (face org-hide)) wrap-prefix #("    " 0 4 (face org-indent)) face org-level-2))
spaces before: ""
pre-existing punct: #(".." 0 2 (fontified t line-prefix #("*" 0 1 (face org-hide)) wrap-prefix #("    " 0 4 (face org-indent)) face org-level-2)) 
#+END_SRC


** Geneva... swans backtrace 

   #+BEGIN_SRC emacs-lisp
Debugger entered--Lisp error: (args-out-of-range -1 -1)
  replace-match("." nil t nil 2)
  (let* ((old-punct (match-string 2)) (was-after-punct (>= old-point (point)))) (replace-match "" nil t nil 1) (replace-match (or (if (and was-after-punct (not (string= old-punct ""))) (progn (let ((potential-new-punct ...)) (find-if (function ...) *smart-punctuation-exceptions*)))) new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn (if was-after-punct (my/fix-space) (save-excursion (my/fix-space))))))
  (let ((old-point (point))) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" (point))) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" (match-string 0))) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" (match-string 1))) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" (match-string 2))) (let* ((old-punct (match-string 2)) (was-after-punct (>= old-point (point)))) (replace-match "" nil t nil 1) (replace-match (or (if (and was-after-punct (not (string= old-punct ""))) (progn (let (...) (find-if ... *smart-punctuation-exceptions*)))) new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn (if was-after-punct (my/fix-space) (save-excursion (my/fix-space)))))))
  (if not-so-smart (let ((old-point (point))) (funcall --cl-go-back-- "[^ 	]") (insert new-punct) (goto-char old-point) (forward-char (length new-punct))) (let ((old-point (point))) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" (point))) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" (match-string 0))) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" (match-string 1))) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" (match-string 2))) (let* ((old-punct (match-string 2)) (was-after-punct (>= old-point (point)))) (replace-match "" nil t nil 1) (replace-match (or (if (and was-after-punct (not ...)) (progn (let ... ...))) new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn (if was-after-punct (my/fix-space) (save-excursion (my/fix-space))))))))
  (let ((--cl-go-back-- (function (lambda (regexp) (re-search-backward regexp nil t) (condition-case nil (progn (forward-char ...)) (error nil)))))) (if not-so-smart (let ((old-point (point))) (funcall --cl-go-back-- "[^ 	]") (insert new-punct) (goto-char old-point) (forward-char (length new-punct))) (let ((old-point (point))) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" (point))) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" (match-string 0))) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" (match-string 1))) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" (match-string 2))) (let* ((old-punct (match-string 2)) (was-after-punct (>= old-point (point)))) (replace-match "" nil t nil 1) (replace-match (or (if (and was-after-punct ...) (progn ...)) new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn (if was-after-punct (my/fix-space) (save-excursion ...))))))))
  (save-restriction (if (and (eql major-mode (quote org-mode)) (org-at-heading-p)) (progn (funcall --cl-print-debug-info-- "at heading\n") (save-excursion (org-beginning-of-line) (let ((heading-text (fifth ...))) (funcall --cl-print-debug-info-- (format "text: %s\n" heading-text)) (if heading-text (progn (search-forward heading-text) (funcall --cl-print-debug-info-- ...) (narrow-to-region ... ...))))))) (let ((--cl-go-back-- (function (lambda (regexp) (re-search-backward regexp nil t) (condition-case nil (progn ...) (error nil)))))) (if not-so-smart (let ((old-point (point))) (funcall --cl-go-back-- "[^ 	]") (insert new-punct) (goto-char old-point) (forward-char (length new-punct))) (let ((old-point (point))) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" (point))) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" (match-string 0))) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" (match-string 1))) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" (match-string 2))) (let* ((old-punct (match-string 2)) (was-after-punct (>= old-point ...))) (replace-match "" nil t nil 1) (replace-match (or (if ... ...) new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn (if was-after-punct ... ...))))))))
  (let ((--cl-print-debug-info-- (function (lambda (s) (save-current-buffer (set-buffer debug-buffer) (insert s)))))) (save-restriction (if (and (eql major-mode (quote org-mode)) (org-at-heading-p)) (progn (funcall --cl-print-debug-info-- "at heading\n") (save-excursion (org-beginning-of-line) (let ((heading-text ...)) (funcall --cl-print-debug-info-- (format "text: %s\n" heading-text)) (if heading-text (progn ... ... ...)))))) (let ((--cl-go-back-- (function (lambda (regexp) (re-search-backward regexp nil t) (condition-case nil ... ...))))) (if not-so-smart (let ((old-point (point))) (funcall --cl-go-back-- "[^ 	]") (insert new-punct) (goto-char old-point) (forward-char (length new-punct))) (let ((old-point (point))) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" (point))) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" (match-string 0))) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" (match-string 1))) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" (match-string 2))) (let* ((old-punct ...) (was-after-punct ...)) (replace-match "" nil t nil 1) (replace-match (or ... new-punct) nil t nil 2) (if (looking-at "[ 	]*\\<") (progn ...))))))))
  (let ((debug-buffer (generate-new-buffer (generate-new-buffer-name "smart-punctutation-debug")))) (let ((--cl-print-debug-info-- (function (lambda (s) (save-current-buffer (set-buffer debug-buffer) (insert s)))))) (save-restriction (if (and (eql major-mode (quote org-mode)) (org-at-heading-p)) (progn (funcall --cl-print-debug-info-- "at heading\n") (save-excursion (org-beginning-of-line) (let (...) (funcall --cl-print-debug-info-- ...) (if heading-text ...))))) (let ((--cl-go-back-- (function (lambda ... ... ...)))) (if not-so-smart (let ((old-point ...)) (funcall --cl-go-back-- "[^ 	]") (insert new-punct) (goto-char old-point) (forward-char (length new-punct))) (let ((old-point ...)) (funcall --cl-print-debug-info-- (format "point: %s\n" old-point)) (funcall --cl-go-back-- (format "[^ 	%s]\\|\\`" *smart-punctuation-marks*)) (funcall --cl-print-debug-info-- (format "before spaces: %s\n" ...)) (re-search-forward (format "\\([ 	]*\\)\\([%s]*\\)" *smart-punctuation-marks*) nil t) (funcall --cl-print-debug-info-- (format "whole match: %S\n" ...)) (funcall --cl-print-debug-info-- (format "spaces before: %S\n" ...)) (funcall --cl-print-debug-info-- (format "pre-existing punct: %S\n" ...)) (let* (... ...) (replace-match "" nil t nil 1) (replace-match ... nil t nil 2) (if ... ...))))))))
  smart-punctuation(".")
  smart-period()
  #<subr call-interactively>(smart-period nil nil)
  ad-Advice-call-interactively(#<subr call-interactively> smart-period nil nil)
  apply(ad-Advice-call-interactively #<subr call-interactively> (smart-period nil nil))
  call-interactively(smart-period nil nil)
  command-execute(smart-period)

   #+END_SRC


** comma error


   #+BEGIN_SRC emacs-lisp
at heading
text: Now rate how willing you were to have these sensations/feelings without acting on them, i.e. trying to manage them, get rid of them, suppress them, run from them (0 to 8): 
   #+END_SRC
