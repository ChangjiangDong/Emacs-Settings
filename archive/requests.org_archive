
Archived entries from file /Users/jay/Dropbox/emacs/prelude/personal/requests.org


** TODO [#A] gnu-emacs-startup.org: [[file:gnu-emacs-startup.org::*Change%20"defadvice%20capitalize-word"%20so%20that%20capitalize%20word%20doesn't%20downcase%20past%20a%20line%20break][Change "defadvice capitalize-word" so that capitalize word doesn't downcase past a line break]]
** TODO [#A] [[*add%20"capitalize%20first%20word%20of%20next%20sentence"%20to%20smart-period,%20smart-question-mark,%20and%20smart-exclamation%20mark][add "capitalize first word of next sentence" to smart-period, smart-question-mark, and smart-exclamation mark]]


* DONE [#A] smart-org-meta-return-dwim
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-27 Sat 16:52
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/requests.org
  :ARCHIVE_OLPATH: archive of completed/approved requests
  :ARCHIVE_CATEGORY: requests
  :ARCHIVE_TODO: DONE
  :ARCHIVE_ITAGS: ARCHIVE
  :END:
I use org-mode for two different things:

1. As a TODO list manager
2. As a text outliner

I'd like org-meta-return to work differently based on context.

1. TODO list: no blank lines
2. text outline: automatically insert 1 blank line when non-heading text precedes a heading

In other words, when I'm doing a TODO list when I have many headings in a row, I don't want stray line breaks between them.

*** For TODO list mode, no blank lines:
#+BEGIN_EXAMPLE
** Organize Party
** TODO Call people
*** TODO Peter
*** DONE Sarah
** TODO Buy food
** DONE Talk to neighbor
#+END_EXAMPLE

However, when I'm writing text, I want line breaks for the sake of visual whitespace / ease of reading.

*** For outline mode, blank line before heading:
#+BEGIN_EXAMPLE

* archive of completed/approved requests                            :ARCHIVE:
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-06-28 Sun 16:51
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/requests.org
  :ARCHIVE_CATEGORY: requests
  :END:
  #+OPTIONS: f:t 





** DONE [#A] org-return-follows-link
Another edge case: hitting return when on an org-mode link (see variable org-return-follows-link). With smart-return, return no longer follows link. Can we make it so this functionality is preserved with smart-return? Thanks!


** TESTING [#B] in shared-functions.org, make the function replace-smart-quotes operate on pasteboard contents when there is no region set?
And can we create a function pasteboard-paste-without-smart-quotes that does replace-smart-quotes on the OSX pasteboard contents, then runs pasteboard-paste? Thanks!

*** NOTE-TO-JAY Request for clarification

   I'm not quite sure I understand the requests. You intend to actually *alter* the pasteboard contents? What is the purpose of that? By your request I imagine you'd want to copy from the web some snippet with smart quotes, like:

: These are smart quotes: “ ” ‘ ’

   Then run ~replace-smart-quotes~, and the next time you'd yank, you'd get:

: These are smart quotes: " " ' '

   But note that if you'd paste it onto another program, you'd get this latter string too.

   I know there is an API to access pasteboard contents (~ns-get-pasteboard~, ~ns-set-pasteboard~), but since I'm not running an OS X, it is difficult for me to check that... but not impossible.

   Now, there is an alternative, which would be to ~pasteboard-paste~, and *then* ~replace-smart-quotes~ over the pasted text. I think this would be cleaner, since it wouldn't interfere with the pasteboard.
*** NOTE-TO-RÚDI answer
Yes, this second solution should work!

*** NOTE-TO-JAY Try this

#+BEGIN_SRC emacs-lisp
(defun pasteboard-paste-without-smart-quotes ()
  (interactive)
  (let ((beg (point)))
    (pasteboard-paste)
    (replace-smart-quotes beg (point))))
#+END_SRC


** DONE [#A] smart-return
Can we create a function smart-return? In org-mode, I will bind (kbd <RETURN>) to it.

A function that will:
1. Insert line break (obviously)
2. When there is a region set, REPLACE region with a line break, the same way a highlighted region is already replaced if you had an alphanumeric key.
3. Check to see if point is in a plain-text list, and if so, run org-meta-return instead of return.

Example:

#+BEGIN_EXAMPLE
- first item
- second item^
#+END_EXAMPLE

Suppose the carat ^ represents where the point is, and I hit <RETURN>.

Current output:
#+BEGIN_EXAMPLE
- first item
- second item
^
#+END_EXAMPLE

Desired output:
#+BEGIN_EXAMPLE
- first item
- second item
- ^
#+END_EXAMPLE

Does that make sense? Thanks!

*** NOTE-TO-JAY Answer

   I just don't understand one thing in your example: why did org produce "* -"? Why not just:

#+BEGIN_EXAMPLE
- first item
- second item
- ^
#+END_EXAMPLE

*** NOTE-TO-JAY Answer
You are right. Apologies, that was a typographical error.


*** NOTE-TO-JAY Answer
What should happen in the following example:

#+BEGIN_EXAMPLE
- this
- that^ and the other
#+END_EXAMPLE

   If you invoke my suggested implementation of ~smart-return~, it will give this output:

#+BEGIN_EXAMPLE
- this
- that
- ^and the other
#+END_EXAMPLE

*** NOTE-TO-JAY Answer
Yes! That is the desired output.


#+BEGIN_SRC emacs-lisp
(defun smart-return ()
  (interactive)
  (cond (mark-active
         (progn (delete-region (mark) (point))
                (newline)))
        ;; Shamefully lifted from `org-return'. Why isn't there an
        ;; `org-at-link-p' function?!
        ((and org-return-follows-link
              (let ((tprop (get-text-property (point) 'face)))
                (or (eq tprop 'org-link)
                    (and (listp tprop) (memq 'org-link tprop)))))
         (call-interactively 'org-open-at-point))
        ((and (eq major-mode 'org-mode)
              (let ((el (org-element-at-point)))
                (and el
                     ;; point is at an item
                     (eq (first el) 'item)
                     ;; item is empty
                     (eql (getf (second el) :contents-begin)
                          (getf (second el) :contents-end)))))
         (beginning-of-line)
         (let ((kill-whole-line nil))
           (kill-line))
         (newline))
        ((and (eq major-mode 'org-mode)
              (let ((el (org-element-at-point)))
                (and el
                     (or (member (first el) '(item plain-list))
                         (let ((parent (getf (second el) :parent)))
                           (and parent
                                (member (first parent) '(item plain-list))))))))
         (org-meta-return))
        (t (org-return))))

(define-key key-minor-mode-map (kbd "RET") 'smart-return)
(define-key org-mode-map (kbd "RET") 'smart-return)

#+END_SRC


*** NOTE-TO-RÚDI Excellent!
Excellent! Seems to be working perfectly. Now can we add one feature? I’d like to be able to "escape" the plain text list by invoking smart-return on a line with no text (other than "- "). When I invoke smart-return on a line with no text, it should enter a line break and no "-".

#+BEGIN_EXAMPLE
- this
- that
- ^
#+END_EXAMPLE

Let's say the point is on the carat. Now if I do smart-return, I’d like this output:

#+BEGIN_EXAMPLE
- this
- that

^
#+END_EXAMPLE

Thanks!
**** NOTE-TO-JAY Try it now

I think it covers the two requirements you added above.



** DONE [#A] disable cycling between hyphen and ellipsis?
Can you disable cycling between hyphen and ellipsis? It's a great idea but I realize there are times when I want to type a long line of 30 periods in a row (without using the number prefix). Should I just add ".........................." to smart-punctuation-exceptions? Thanks!

*** NOTE-TO-JAY Answer

    Yes, adding that as an exception should work. 


** DONE [#C] cycle punctuation 

create a function cycle-punctuation. Kind of like cycle-hyphenation, except that invoking cycle-punctuation would change the punctuation at the end of a sentence between "." "!" "?" and back again. Such that given the sentence...

: The rain in Spain falls mainly on the plains. 

...and assuming the point was on the "T" or the "." or anywhere in between, invoking cycle-punctuation would leave the point wherever it was and cycle between these three states:

: The rain in Spain falls mainly on the plains. 
: The rain in Spain falls mainly on the plains? 
: The rain in Spain falls mainly on the plains! 

In fact, let's create a cycle-punctuation function also, even if the smart-punctuation functions above are also feasible. Here's some code that might help. 
http://ergoemacs.org/emacs/elisp_change_space-hyphen_underscore.html 

Thanks!!

(define-key org-mode-map (kbd "M-.") 'cycle-punctuation)

*** NOTE-TO-JAY Implementation & question

    What should happen when the sentence doesn't end with any of these markers? My suggested implementation (below) does nothing.
*** 
*** NOTE-TO-RUDI Answer
Perfect.


** DONE [#C] yet another edge case for kill-word-correctly-and-capitalize
Here's another edge case.

: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought thought Alice, "without pictures or conversations?"

Suppose the point is on the "t" in the first "thought" and I invoke kill-word-correctly-and-capitalize.

Current output:
: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book,"thought Alice, "without pictures or conversations?"

Desired output:
: Into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought Alice, "without pictures or conversations?"

This function is becoming more and more useful!

*** NOTE-TO-JAY Question

   The culprit here seems to be again ~my/fix-space~. I see you added the following clause:

: (looking-back "\" ")

   This means that after fixing the spaces, if you look back from point to '" ', you should delete the space. I suppose that's only true if: (1) the quotation marks are starting a quote, or (2) there is a punctuation mark ahead (which is handled by another clause).

   So, what was the intention here?
*** NOTE-TO-RÚDI Answer
Hmm, I'm not sure I remember what I intended there. I must have been trying to address an edge case I found myself. If it makes sense to remove that clause again, let's do so, and if I find another edge case, we can address it at that point.

In general, I will use quotation marks and punctuation in the style/sequence reflected below:

#+BEGIN_QUOTE
Alice was beginning to get very tired of sitting by her sister on the bank (and of having nothing to do). Once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it. "And what is the use of a book," thought Alice, "without pictures or conversations."
#+END_QUOTE

Thanks!

*** NOTE-TO-JAY About the quotation marks

OK, I removed the clauses pertaining to the quotation marks. Indeed, it is hard to determine, when you are looking at a single quotation mark, if it is starting or ending the quote. You must pair it with the previous or next; in the limit you have to take into account the whole buffer. There is probably code out there that does it (note that ~emacs-lisp-mode~, for example, colourises strings -- therefore, it must know when a string starts or ends). I can search for it if you want.
*** NOTE-TO-RÚDI yes, later
Yes, that would be great, but let's deprioritize it. Thanks!



*** DONE [#A] an edge case for kill-clause
Can we make kill-clause count "(" as punctuation? 

Consider:

: So she was considering in her own mind (as well as she could, for the hot day made her feel very sleepy and stupid).

Suppose the point is on the "S" in "So" and I invoke kill-clause.

Current output:
:, for the hot day made her feel very sleepy and stupid).

Desired output: 
: (as well as she could, for the hot day made her feel very sleepy and stupid).

I tried adding "(" to ~(let ((sentence-end-base~ in kill-clause, but it doesn't seem to have worked. Thanks!

**** NOTE-TO-JAY Answer

   Hm, the hacking fell short. You see, ~my/kill-sentence-dwim~ always expects spaces between sentences, and since there is no space after '(', it could never catch it. We'll have to refactor it.

   I added a new version, though I can already think of some edge cases.

: Killing causes doesn't work e.g. on this sentence.

   If you call ~kill-clause~ with point on 'K', it will kill until the ' in doesn't. If point is on 'w' from 'work', it will kill until the 'e' in 'e.g.'. I don't suppose this is desired behaviour. Do you confirm? Should I handle it?

**** NOTE-TO-RÚDI Yes please. 
Yes, if you could handle this, that would be great. The two cases you mention above are frequent cases for me, so handling them is high-priority. 

**** NOTE-TO-JAY OK, but...

   The last period in 'e.g.' is not so easy to handle, especially since you don't use double spaces after sentences. Emacs' sentence and fill functionalities (at least) use ~sentence-end-double-space~ to determine where sentences end -- if the variable is t, a double space is required after the punctuation mark, otherwise only one. This serves exactly the purpose of solving this problem. This is taken from the [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Sentences.html][Emacs Manual]]:

#+BEGIN_QUOTE
The sentence commands assume that you follow the American typist’s convention of putting two spaces at the end of a sentence. That is, a sentence ends wherever there is a ‘.’, ‘?’ or ‘!’ followed by the end of a line or two spaces, with any number of ‘)’, ‘]’, ‘'’, or ‘"’ characters allowed in between. A sentence also begins or ends wherever a paragraph begins or ends. It is useful to follow this convention, because it allows the Emacs sentence commands to distinguish between periods that end a sentence and periods that indicate abbreviations.
#+END_QUOTE

   So, in the example I gave above:

: Killing causes doesn't work e.g. on this sentence.

   And if point in on 'K', and after fixing the problem with ', killing the clause would nonetheless yield:

: on this sentence.

   The same happens if you ~kill-sentence~, BTW.
**** NOTE-TO-RÚDI Answer
Got it. In that case, let's not worry about the case of "e.g." As long as the "don't" case works, which it seems to, I am satisfied. 


*** DONE [#B] cycle-hyphenation for multiple words
Can we modify cycle-hyphenation so that it can successfully hyphenate more than 2 words? 

: He is the editor in chief of the magazine. 

Suppose the point is on the "e" in "editor" and I invoke cycle-hyphenation 2 times in a row. 

Current output:
: He is the editor-in chief-of the magazine. 

Desired output:
: He is the editor-in-chief of the magazine. 

Can we modify cycle-hyphenation to deal with this special case? Thanks! :-)

**** NOTE-TO-JAY Answer

   OK, but I changed the semantics of the command slightly. Take your example:

: He is the editor in chief of the magazine. 

   Suppose the point is NOT on the 'e', but on the SPACE just before it. With the previous version, you'd get:

: He is the editor-in chief of the magazine. 

   As desired. With the new version, you get:

: He is the-editor in chief of the magazine. 

   Which is not desired. So: always ~cycle-hyphenise~ when point is ON or AFTER the beginning of the word you wish to join with the following. Same goes with the cycling back from - to space.

**** NOTE-TO-JAY Answer
Got it. Thanks!! 


*** DONE [#A] isearch contents of pasteboard
can we add a function to search within the current buffer, using the contents of the OS X system pasteboard as the search term? See pasteboard-paste above.

i.e. so this way I don't have to do isearch-forward and THEN also pasteboard-paste to paste in the search term I want. if for example I've already copied the search term from another buffer or from Chrome, I want to be able to search for it with one keystroke. Thanks!

**** NOTE-TO-JAY Try this

#+BEGIN_SRC emacs-lisp
(defun pasteboard-search-in-current-buffer ()
  (interactive)
  (let ((search-term
         (with-temp-buffer
           (pasteboard-paste)
           (buffer-string))))
    (search-forward search-term)))

(define-key key-minor-mode-map (kbd "s-F") 'pasteboard-search-in-current-buffer) 
#+END_SRC

**** NOTE-TO-RÚDI Seems to work. Thank you! 



*** DONE [#B] self insert space 

Can we create a command to self-insert space? Which I'll bind to M-SPC in case I ever need to insert a space the old-fashioned way without invoking all this fancy DWIM stuff. Thanks. :-)

**** NOTE-TO-JAY Try this

    Not sure if this is what you want -- and it might have undesired consequences -- but this basically switches the SPC and M-SPC events:

# #+BEGIN_SRC emacs-lisp
(define-key key-translation-map (kbd "SPC") (kbd "M-SPC"))
(define-key key-translation-map (kbd "M-SPC") (kbd "SPC"))
# #+END_SRC 

    If SPC is bound to ~self-insert-command~, and M-SPC to ~jay/insert-space~ or any other function, then this will switch the invoked commands; meaning, if you hit SPC, it will be like hitting M-SPC, and M-SPC will be like hitting SPC.

    I'll leave it commented, since I don't know if this is really what you want. 
**** NOTE-TO-RUDI dealing with the minibuffer 
seems to work! thank you!

Update: I ran into problems in the minibuffer. Seems like the key translation switcheroo doesn't work in the minibuffer? When I call ~helm-M-x~ and then enter a word followed by a space (e.g. "org agenda") it reads the space as M-SPC and I get an error. 

I tried this... 

(define-key minibuffer-local-map (kbd "<M-SPC>") 'jay/insert-space) 
(global-set-key (kbd "<M-SPC>") 'jay/insert-space) 

...but it didn't fix the problem.

Again, the goal is to have a way (ideally through M-SPC) to add an arbitrary number of spaces, ignoring the my/fix-space constraints we've created.

***** NOTE-TO-JAY 

    I see. Well, that's the kind of "undesired consequences" I imagined could happen indeed.

    Forget about the switcheroo. Here, try this:

#+BEGIN_SRC emacs-lisp
(defun insert-space ()
  (interactive)
  (let ((last-command-event ? ))
    (call-interactively 'self-insert-command)))

(global-set-key (kbd "M-SPC") 'insert-space)
#+END_SRC 


*** DONE [#B] list of abbrevs to be expanded to TextExpander as case-sensitive 
can we implement a way for me to add words to a list of export-to-TextExpander exceptions i.e. words that are >1char that should be exported as case-sensitive, i.e. abbrevationMode 0

e.g. 
(setq textexpander-export-as-case-sensitive-list 
  ("id" "wed" "im" "sd" "uk" "US" "OS" "CK")) 

**** NOTE-TO-JAY Try it

     I added it to export-to-text-expander.el.

**** DONE [#A] make kill-word-correctly-and-capitalize count a line break as a word 
Rúdi, 

Before I asked you to make kill-word-correctly kill not only words one at a time, but also punctuation one at a time, such that given this... 

#+BEGIN_QUOTE
The sea. Ocean. 

I still remember that day.
#+END_QUOTE 

...and supposing the point was on the T in The, invoking kill-word-correctly twice would kill "The" and "sea" but leave in period, and invoking it a third time would kind the period as well. And you implemented this perfectly. 

Now I’d like to make kill-word-correctly and kill-word-correctly-and-capitalize recognize line breaks in the same way, counting each line break as a word. 

In the above, let's say the point is on the "O" in "Ocean". And let's say I invoke kill-word-correctly-and-capitalize 3 times. 

Current output: 

#+BEGIN_QUOTE
The sea. still remember that day.
#+END_QUOTE 

Desired output: 

#+BEGIN_QUOTE
The sea. 
I still remember that day.
#+END_QUOTE 

Thanks!

**** DONE [#A] an edge case for kill-word-correctly-and-capitalize

#+BEGIN_QUOTE
He's a science writer specializing in psychology (NYT, Wired, Psychology Today). 
#+END_QUOTE

Suppose the point is on the "is" in "specializing" and my goal is to invoke kill-word-correctly-and-capitalize 3 times in order to kill the phrase "specializing in psychology".

Current output: 
He's a science writer(NYT, Wired, Psychology Today). 

Desired output: 
He's a science writer specializing in psychology (NYT, Wired, Psychology Today). 

Note that the same output is created if I highlight the phrase "specializing in psychology" and hit my/delete-backward.

Can we fix for both kill-word-correctly-and-capitalize and my/delete-backward? Thanks!

***** DONE Try it now

      The problem was with ~my/fix-space~, which was deleting spaces before punctuation indiscriminately. Now it only deletes spaces before the characters: .,:;!?»)-. Note that this will affect many other functions, sice ~my/fix-space~ is called in a number of places. I think the result will nonetheless be the desired one.


**** kill clause

I want to use this to create a function to kill-clause (not kill sentence).


**** DONE! :-) There's no doubt a better way to do this than the way I did it, which is to redefine sentence-end-base, kill the "sentence," then redefining sentence-end-base back again. :rudi:

#+BEGIN_SRC emacs-lisp
;;; old version; try the one below and replace it if it is working as intended.
;; (defun kill-clause ()
;;   (interactive) 
;; (expand-abbrev)
;;               (when (string-match "^\\[" sentence-end-base)
;;     (progn 
;;               (setq sentence-end-base
;;                       (replace-match "--\\|[,;.?!…/" t t sentence-end-base)))
;; (my/kill-sentence-dwim)
;; (setq sentence-end-base "[.?!…][]\"'”)}]*")))
#+END_SRC

***** DONE! :-) DONE Request for clarification                 :followup:

: Please clarify what you intend to do with this command.  From what I gather, you intend this function to do exactly what my/kill-sentence-dwim, as if "--", "," and ";" also marked the end of a sentence. If that is the case, then why do you also add the characters "?!…" to sentence-end-base, given that they (presumably) were already there?

I may have made a mistake. My intention is that: 

1. kill-clause should kill text up to -- --- , ; ! ? ... or . 
2. my/kill-sentence-dwim should kill text up to ! ? ... or .

Otherwise, yes, it should work exactly like my/kill-sentence-dwim. Thank you! 

***** DONE! :-) Try this

    Well, it is a pretty clever way of doing it... you're thinking like a true hacker. :) However, ~setq~'ing like in the Wild West is dangerous.

: Haha! Thank you!

    ~let~ will be your friend here.

#+BEGIN_SRC emacs-lisp
;; Identify the end of sentences globally.
(setq sentence-end-base "[.?!…][]\"'”)}]*")

;; Clauses are like sentences, but with some additional end markers. Rebind `sentence-end-base' locally to get that effect.
(defun kill-clause ()
  (interactive) 
  (expand-abbrev)
  (let ((sentence-end-base "--\\|[,;.?!…][]\"'”)}]*"))
    (my/kill-sentence-dwim)))
#+END_SRC

: Perfect!

**** DONE [#A] kill word correctly and capitalize 
Rúdi,

Note that I added capitalize-word and left-word to the above. My goal is to instruct Emacs to check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly.

What I did above works, but it breaks when it deals with punctuation. Example #1:

: My fascination began when I was four years old. For some reason, I was immediately intrigued. 

Let's say the point is on the F in For, and my goal is to invoke kill-word-correctly-and-capitalize 4 times, deleting those 3 words plus the comma to wind up with this:

: My fascination began when I was four years old. I was immediately intrigued. 

As you can see, the comma handling gets messed up. 

Example #2:

#+BEGIN_QUOTE
I didn't hurt myself. Meanwhile, 

I still remember that day.
#+END_QUOTE

Let's say the point is on the M in Meanwhile, and my goal is to invoke kill-word-correctly-and-capitalize twice, deleting the word plus the comma to wind up with this: 

#+BEGIN_QUOTE
I didn't hurt myself. 

I still remember that day.
#+END_QUOTE

Example #3:
: This above all, to thine own self be true. 

Say the point is on the T in This and my goal is to invoke kill-word-correctly-and-capitalize 4 times so that the first word is "To."

Your implementation of kill-word-correctly works properly in all the examples above. My goal is to get kill-word-correctly-and-capitalize to deal with such cases correctly also. Is it possible to do this, or does the invocation of left-word mess things up? Thanks! 

**** DONE [#B] Create an exception to smart-punctuation 
so it doesn't invoke when it's at the beginning of a line. I need to be able to write sentences like this:

#+BEGIN_EXAMPLE

- bullet points like this 
- or this 

...and ellipses at the beginning of lines like this.

#+END_EXAMPLE
**** DONE no space between end of word and punctuation mark 
Can make it so that when I invoke punctuation, it removes any space between the word and the punctuation?

#+BEGIN_EXAMPLE
The night is dark But the day is bright. 
#+END_EXAMPLE

Such that, for instance, if the point is on the B in But, and I hit "." Emacs will automatically remove the unwanted space, so that I get this: 

: The night is dark. But the day is bright. 

...instead of this:

: The night is dark .But the day is bright. 

I presume that changing this will have the same effect on , ; : ! and ?

Thanks! 

***** DONE Try it

    I have added the functionality you requested, but I'm not sure about the semicolon and colon; I added a ~smart-~ function for them too, but one that is not so smart: i.e. does not replace the previous punctuation mark; it only tries to fix the spaces around). However, it does not seem reasonable to write ".:", ".;", ":.", etc. If you wish the semi-colon and colon to have the same behaviour as the other punctuation marks (remove the previous mark), you can just remove the "t" in the call to ~smart-punctuation~. 

: Looks great! Yes, I think I'd like ; and : to work the same way. What's the argument against this? Is there some reason it might be helpful for them to operate differently? 

***** DONE [#A] a few requests re the above
1. When I'm typing a sentence and I put a punctuation mark like "." at the end of it, I now automatically get a SPACE after the "."

I am used to hitting the space key after a punctuation mark (and I will need to keep doing so in all other applications, so I'd like Emacs to /not/ insert the space automatically when I'm typing sentences. To do this, I commented out the my/fix-space at the end of smart-punctuation. But now when there's something like this: 

: This. ^

...and if the point is on the ^ above, and I hit "?" Emacs then removes the existing space after cycling to a question mark. 

I'd like smart-punctuation to behave differently based on whether I'm inserting punctuation after a word (no automatic insertion of space) or after an existing punctuation mark in order to cycle it (in which case I’d like to call my/fix-space to make sure there's a space after the punctuation mark).

2. I will sometimes need to write a parenthesis followed by a period, like this: 

#+BEGIN_EXAMPLE
Alice had nothing to do (once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it). ^
#+END_EXAMPLE

To enable this, I tried adding ")." to smart-punctuation-exceptions, which seems to work... but now if I go to point ^ above and hit "?" Emacs then clobbers the parenthesis (not desired) in addition to cycling the period. Can we fix this? 

3. Finally, can we change the behavior of smart-period such that if I forget about the cycling between period and ellipses, and I just type a word followed by hitting period 3 times, it successfully inserts an ellipsis? Maybe the best way to do this would be to just turn off the cycling between period and ellipsis for now. It's a good idea, but I want to be able to type:
<KB>words... </KB>
and get an ellipsis. Thanks! 

**** DONE request: smart punctuation insertion 
Rúdi, can you add a line to the functions below that will automatically delete existing punctuation when one of these smart-punctuation functions gets called?

I'll give you an example of what I mean. Consider this sentence:

: The rain in Spain falls mainly on the plains! 

Let's say the point is on the space after the ! at the end of the sentence.

If I then hit ? (which calls smart-question-mark), Emacs should DELETE the existing ! and then replace it with a ? (and then put a space after it).

The logic of this is that I will NEVER be trying to type anything like:

- Hello!?
- Hello.!
- Hello?.
- Hello,.
- Hello.,

In other words, if the point is after a ; : , ! ? or . and then I hit a punctuation mark, it's almost certain that I am doing this because I wish to CHANGE the punctuation and not ADD one punctuation mark after another. 

***** Exceptions
1. I will often want to type three dots like so:
: To be continued...
2. or occasionally a question mark followed by an exclamation point like so:
: What the hell?!
3. I still need to be able to indicate em dashes---that is, three hyphens in a row.

Is this straightforward to implement, or do the exceptions create a lot of complications? Exception #2 is very rare, so if it creates problems we can forget about it. Really #1 and #3 are the important ones. 


**** TODO line of periods


Alice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do: once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it! "And what is the use of a book," thought Alice, "without pictures or conversations?" 

So she was considering in her own mind (as well as she could, for the hot day made her feel very sleepy and stupid), whether the pleasure of making a daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly a White Rabbit with pink eyes ran close by her.

There was nothing so very remarkable in that; nor did Alice think it so very much out of the way to hear the Rabbit say to itself, "Oh dear! Oh dear! I shall be late!" (When she thought it over afterwards, it occurred to her that she ought to have wondered at this, but at the time it all seemed quite natural.) But when the Rabbit actually took a watch out of its waistcoat-pocket, and looked at it, and then hurried on, Alice started to her feet, for it flashed across her mind that she had never before seen a rabbit with either a waistcoat-pocket, or a watch to take out of it. 


* DONE [#A] check my changes to backward-kill-word-correctly?          :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~jay/insert-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-RÚDI Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block: 
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks! 

*** NOTE-TO-JAY backward-kill-word-correctly

   Again, I'm sorry, but I'm confused. If I remove the ~when~ block (and note that *includes* the call to ~jay/insert-space~), I get exactly the behaviour you intend. So either I'm not making myself clear or our Emacs are behaving differently. So, in order to figure it out, I suggest you try evaluating first the following functions:

#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]")
            (looking-back"( ")
            (looking-at " )")
            )
    (delete-horizontal-space)))

(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)

(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

   Try it on your example:

: Alice was tired---tired as hell. ^

   And then evaluate my suggestion:

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space))
#+END_SRC

   And try it again on your example:

: Alice was tired---tired as hell. ^

   On my settings, I get exactly the same result, which is no space after '---'.

*** NOTE-TO-RÚDI You are right.
I'm not sure what I was doing wrong before. I must have deleted the wrong section before evaluating. In any case, your version works as I intended. Thank you!! 

* DONE [#A] check my changes to backward-kill-word-correctly?          :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~jay/insert-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-RÚDI Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block: 
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks! 

*** NOTE-TO-JAY backward-kill-word-correctly

   Again, I'm sorry, but I'm confused. If I remove the ~when~ block (and note that *includes* the call to ~jay/insert-space~), I get exactly the behaviour you intend. So either I'm not making myself clear or our Emacs are behaving differently. So, in order to figure it out, I suggest you try evaluating first the following functions:

#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]")
            (looking-back"( ")
            (looking-at " )")
            )
    (delete-horizontal-space)))

(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)

(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

   Try it on your example:

: Alice was tired---tired as hell. ^

   And then evaluate my suggestion:

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space))
#+END_SRC

   And try it again on your example:

: Alice was tired---tired as hell. ^

   On my settings, I get exactly the same result, which is no space after '---'.

*** NOTE-TO-RÚDI You are right.
I'm not sure what I was doing wrong before. I must have deleted the wrong section before evaluating. In any case, your version works as I intended. Thank you!! 

* DONE [#A] check my changes to backward-kill-word-correctly?          :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~jay/insert-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-RÚDI Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block: 
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks! 

*** NOTE-TO-JAY backward-kill-word-correctly

   Again, I'm sorry, but I'm confused. If I remove the ~when~ block (and note that *includes* the call to ~jay/insert-space~), I get exactly the behaviour you intend. So either I'm not making myself clear or our Emacs are behaving differently. So, in order to figure it out, I suggest you try evaluating first the following functions:

#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]")
            (looking-back"( ")
            (looking-at " )")
            )
    (delete-horizontal-space)))

(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)

(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

   Try it on your example:

: Alice was tired---tired as hell. ^

   And then evaluate my suggestion:

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space))
#+END_SRC

   And try it again on your example:

: Alice was tired---tired as hell. ^

   On my settings, I get exactly the same result, which is no space after '---'.

*** NOTE-TO-RÚDI You are right.
I'm not sure what I was doing wrong before. I must have deleted the wrong section before evaluating. In any case, your version works as I intended. Thank you!! 

* DONE [#A] check my changes to backward-kill-word-correctly?          :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~jay/insert-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-RÚDI Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block: 
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks! 

*** NOTE-TO-JAY backward-kill-word-correctly

   Again, I'm sorry, but I'm confused. If I remove the ~when~ block (and note that *includes* the call to ~jay/insert-space~), I get exactly the behaviour you intend. So either I'm not making myself clear or our Emacs are behaving differently. So, in order to figure it out, I suggest you try evaluating first the following functions:

#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]")
            (looking-back"( ")
            (looking-at " )")
            )
    (delete-horizontal-space)))

(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)

(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

   Try it on your example:

: Alice was tired---tired as hell. ^

   And then evaluate my suggestion:

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space))
#+END_SRC

   And try it again on your example:

: Alice was tired---tired as hell. ^

   On my settings, I get exactly the same result, which is no space after '---'.

*** NOTE-TO-RÚDI You are right.
I'm not sure what I was doing wrong before. I must have deleted the wrong section before evaluating. In any case, your version works as I intended. Thank you!! 

* DONE [#A] check my changes to backward-kill-word-correctly?          :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~jay/insert-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-RÚDI Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block: 
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks! 

*** NOTE-TO-JAY backward-kill-word-correctly

   Again, I'm sorry, but I'm confused. If I remove the ~when~ block (and note that *includes* the call to ~jay/insert-space~), I get exactly the behaviour you intend. So either I'm not making myself clear or our Emacs are behaving differently. So, in order to figure it out, I suggest you try evaluating first the following functions:

#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]")
            (looking-back"( ")
            (looking-at " )")
            )
    (delete-horizontal-space)))

(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)

(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

   Try it on your example:

: Alice was tired---tired as hell. ^

   And then evaluate my suggestion:

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space))
#+END_SRC

   And try it again on your example:

: Alice was tired---tired as hell. ^

   On my settings, I get exactly the same result, which is no space after '---'.

*** NOTE-TO-RÚDI You are right.
I'm not sure what I was doing wrong before. I must have deleted the wrong section before evaluating. In any case, your version works as I intended. Thank you!! 


* TODO [#A] check my changes to backward-kill-word-correctly?          :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~jay/insert-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-RÚDI Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block: 
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks! 

*** NOTE-TO-JAY backward-kill-word-correctly

   Again, I'm sorry, but I'm confused. If I remove the ~when~ block (and note that *includes* the call to ~jay/insert-space~), I get exactly the behaviour you intend. So either I'm not making myself clear or our Emacs are behaving differently. So, in order to figure it out, I suggest you try evaluating first the following functions:

#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]")
            (looking-back"( ")
            (looking-at " )")
            )
    (delete-horizontal-space)))

(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)

(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

   Try it on your example:

: Alice was tired---tired as hell. ^

   And then evaluate my suggestion:

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space))
#+END_SRC

   And try it again on your example:

: Alice was tired---tired as hell. ^

   On my settings, I get exactly the same result, which is no space after '---'.

*** NOTE-TO-RÚDI You are right.
I'm not sure what I was doing wrong before. I must have deleted the wrong section before evaluating. In any case, your version works as I intended. Thank you!! 

* TODO [#A] check my changes to backward-kill-word-correctly?          :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~jay/insert-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-RÚDI Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block: 
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks! 

*** NOTE-TO-JAY backward-kill-word-correctly

   Again, I'm sorry, but I'm confused. If I remove the ~when~ block (and note that *includes* the call to ~jay/insert-space~), I get exactly the behaviour you intend. So either I'm not making myself clear or our Emacs are behaving differently. So, in order to figure it out, I suggest you try evaluating first the following functions:

#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]")
            (looking-back"( ")
            (looking-at " )")
            )
    (delete-horizontal-space)))

(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)

(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

   Try it on your example:

: Alice was tired---tired as hell. ^

   And then evaluate my suggestion:

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space))
#+END_SRC

   And try it again on your example:

: Alice was tired---tired as hell. ^

   On my settings, I get exactly the same result, which is no space after '---'.

*** NOTE-TO-RÚDI You are right.
I'm not sure what I was doing wrong before. I must have deleted the wrong section before evaluating. In any case, your version works as I intended. Thank you!! 

* TODO [#A] check my changes to backward-kill-word-correctly?          :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~jay/insert-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-RÚDI Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block: 
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks! 

*** NOTE-TO-JAY backward-kill-word-correctly

   Again, I'm sorry, but I'm confused. If I remove the ~when~ block (and note that *includes* the call to ~jay/insert-space~), I get exactly the behaviour you intend. So either I'm not making myself clear or our Emacs are behaving differently. So, in order to figure it out, I suggest you try evaluating first the following functions:

#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]")
            (looking-back"( ")
            (looking-at " )")
            )
    (delete-horizontal-space)))

(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)

(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

   Try it on your example:

: Alice was tired---tired as hell. ^

   And then evaluate my suggestion:

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space))
#+END_SRC

   And try it again on your example:

: Alice was tired---tired as hell. ^

   On my settings, I get exactly the same result, which is no space after '---'.

*** NOTE-TO-RÚDI You are right.
I'm not sure what I was doing wrong before. I must have deleted the wrong section before evaluating. In any case, your version works as I intended. Thank you!! 

* TODO [#A] check my changes to backward-kill-word-correctly?          :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~jay/insert-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-RÚDI Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block: 
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks! 

*** NOTE-TO-JAY backward-kill-word-correctly

   Again, I'm sorry, but I'm confused. If I remove the ~when~ block (and note that *includes* the call to ~jay/insert-space~), I get exactly the behaviour you intend. So either I'm not making myself clear or our Emacs are behaving differently. So, in order to figure it out, I suggest you try evaluating first the following functions:

#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]")
            (looking-back"( ")
            (looking-at " )")
            )
    (delete-horizontal-space)))

(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)

(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

   Try it on your example:

: Alice was tired---tired as hell. ^

   And then evaluate my suggestion:

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space))
#+END_SRC

   And try it again on your example:

: Alice was tired---tired as hell. ^

   On my settings, I get exactly the same result, which is no space after '---'.

*** NOTE-TO-RÚDI You are right.
I'm not sure what I was doing wrong before. I must have deleted the wrong section before evaluating. In any case, your version works as I intended. Thank you!! 

* TODO [#A] check my changes to backward-kill-word-correctly?          :rudi:
Rúdi: desired behavior is that when invoking backward-kill-word-correctly to delete words backwards, Emacs should leave a space after the word to the left of the point UNLESS point is at the beginning of the line or after "---"

I tried to implement this myself, below. My hack seems to work, but it seems slow... Is it possible to make it faster or no? maybe just than a look at the below and see if you think I implemented it in the best way.

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

** NOTE-TO-JAY Question

   Since ~backward-kill-word-correctly~ already calls ~my/fix-space~, isn't a call to ~jay/insert-space~ redundant? What was the use case you were thinking of when you originally added it? Note that if you remove the whole ~(when ...)~ block, it apparently works as you intend it to work...

** NOTE-TO-RÚDI Answer
Good question. The answer is that there should never be a space after "---"

Example:
: Alice was tired---tired as hell. ^

Say the point is the carat, and I invoke backward-kill-word-correctly 4 times.

Output if I remove the whole ~(when ...)~ block: 
: Alice was tired--- ^
Note the space after "---"

Desired output:
: Alice was tired---^
No space. Does that make sense? Thanks! 

*** NOTE-TO-JAY backward-kill-word-correctly

   Again, I'm sorry, but I'm confused. If I remove the ~when~ block (and note that *includes* the call to ~jay/insert-space~), I get exactly the behaviour you intend. So either I'm not making myself clear or our Emacs are behaving differently. So, in order to figure it out, I suggest you try evaluating first the following functions:

#+BEGIN_SRC emacs-lisp
(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (or (looking-back "^[[:space:]]+")
            (looking-back "-[[:space:]]+")
            (looking-at "[.,:;!?»)-]")
            (looking-back"( ")
            (looking-at " )")
            )
    (delete-horizontal-space)))

(defun jay/insert-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(expand-abbrev)
(insert "\ ")
  (just-one-space)
)

(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space)

;; I added this ↓↓↓ #######################
(when (and
(not (looking-back "---")) ; I added this
(not (looking-back "^"))) ; I added this
;; I added this ↑↑↑ #######################

(jay/insert-space)
)
)
#+END_SRC

   Try it on your example:

: Alice was tired---tired as hell. ^

   And then evaluate my suggestion:

#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly ()
  "Kill word."
  (interactive)
  (if (re-search-backward "\\>\\W*[[:punct:]]+\\W*\\=" nil t)
      (kill-region (match-end 0) (match-beginning 0))
    (backward-kill-word 1))
  (my/fix-space))
#+END_SRC

   And try it again on your example:

: Alice was tired---tired as hell. ^

   On my settings, I get exactly the same result, which is no space after '---'.

*** NOTE-TO-RÚDI You are right.
I'm not sure what I was doing wrong before. I must have deleted the wrong section before evaluating. In any case, your version works as I intended. Thank you!! 


** TODO [#C] speed up launch?                                        :emacs:
Hi Rúdi,

I'd like to make Emacs launch faster, so that I can launch and just start typing text in org-mode as fast as possible when I need to start typing quickly. (Say I get a phone call and I need to take down a number, etc.) Can we set it up so that as much as possible gets lazy-loaded or loads after launch? 

Also in shared-functions.org, I have lines like this:

#+BEGIN_SRC emacs-lisp
(load "~/Dropbox/github/koma3/ox-koma-letter.el")
(load "~/Dropbox/github/koma3/fiverr-koma.el") 
#+END_SRC

It's my own customized version of ox-koma letter, but it certainly doesn't need to launch right away. I use it rarely...

Thanks!

*** NOTE-TO-JAY Answer

    Well, I can think of two ways to speed up launch:

    1. Autoloading as much as possible. Here's [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Autoload.html][info]] on it. In the example you gave, you'd probably write something like: 
    #+BEGIN_EXAMPLE
    (autoload 'org-koma-letter-export-as-latex "~/Dropbox/github/koma3/ox-koma-letter.el" nil t)
    ...
    #+END_EXAMPLE
    This registers the command ~org-koma-letter-export-as-latex~ as loadable from the latter path. This of course has the downside of having to specify all commands of a module discriminately so that the module gets loaded when one of those commands is invoked.

    2. Having a separate "vanilla" configuration, which you could start Emacs with when you wanted to start typing fast. You could then have different icons on your desktop: one for your heavyweight Emacs, and another for your vanilla one.

    What do you find more appealing?

**** NOTE-TO-RÚDI Answer
Definitely #1. For this particular functionality, I decided to just move those files into my load path. But anything else we can do to lazy-load other functionality or eval after launch of Emacs would be great! :-)

**** NOTE-TO-JAY Answer

    OK, I've been doing some research on autoloading (I didn't know much about it myself), and it turns out that Emacs pretty much handles it in a very straightforward way -- as long as you use the packages facility in a different way.

    Currently, this is your setting:

#+BEGIN_EXAMPLE
(require 'package)

(add-to-list 'package-archives
             '("marmalade" .
               "http://marmalade-repo.org/packages/" ))
(add-to-list 'package-archives
             '("melpa" . "http://melpa.milkbox.net/packages/") t)

(add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/") t)

(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

;; (package-initialize)

(setq package-enable-at-startup nil)

(package-initialize 'noactivate)
#+END_EXAMPLE

    By the look of it, I would assume you once had your installed packages initalised and loaded, and then for some reason you preferred to disable loading the packages upon initialisation. Do you remember why?

    The reason I'm asking is that when you install packages and activate them at startup, Emacs automatically does the "autoload" trick; i.e. it defines only the commands, and defers loading of the actual code to when the commands are used. When you use ~require~, Emacs will force the load of all of the package's code.

    So, two options now:

    1. Revert back to activating packages upon ~package-initialize~ and remove ~require~ calls.

    2. Replace ~require~ calls with ~package-activate~.

    This still doesn't solve the cases where you explicitly ~load~ or ~load-file~; we will handle them later.

**** NOTE-TO-RÚDI Answer
OK great. I don't remember why I did that before. I'm not sure the difference between the two options you listed above, so I am fine with either one. It seems like #1 might be a little easier?

**** NOTE-TO-JAY Progress

     So, this was my procedure:
     1. I reverted to plain old ~package-initialize~ (without the ~noactivate~ param) and removed the statement that was setting ~package-enable-at-startup~ to ~nil~. This should make it so that all your installed packages are available to use when you start Emacs; however, their code isn't loaded until they're actually used (i.e. one of its commands is used). 
     2. I reviewed all ~require~ statements. I used the same ~package-archives~ as you did, and checked whether each of the ~require~'d libraries were installable packages. I assumed you installed them through ~package-install~, and therefore removed the ~require~ statements. I left all the ones that I couldn't find as a package. I know some of them are in this repository, and I can later generate autoloads for them. As for the rest, I will track them down on the internet and do the same.

     For now, I'd like you to test if Emacs is working properly without these ~require~ statements, and check if there is any noticeable difference in startup performance.

     One more thing: I couldn't get my head around what all the code that loads ~edit-server~ is attempting to do. It seems awfully redundant and cumbersome. Do you have any info you could give me on that? Like where did you take it from and why?
**** NOTE-TO-RÚDI Answer
Hi Rúdi,

Great, thanks for doing that! Seems like it is loading a bit faster. I did find that I got errors when I launched as it was: void function auto-capitalize mode, and the same for helm-swoop. I turned those require statements back on and the issue resolved. 

As for the edit-server stuff, I'm not sure how I wound up with so much redundancy. I use it for a Chrome extension called [[https://github.com/stsquad/emacs_Chrome][Edit with Emacs]]. I removed all but (edit-server start) and it works, so good call! 


* TODO [#A] kill-line-and-capitalize [1/3]
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-07-09 Thu 10:24
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/requests.org
  :ARCHIVE_OLPATH: open requests/Emacs
  :ARCHIVE_CATEGORY: requests
  :ARCHIVE_TODO: TODO
  :END:
Can you add something like this: 

(save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-word 1))))

to:

- [X] pasteboard-cut.
- [ ] kill-line. EDIT: I should have said my/kill-line-dwim 
- [ ] kill-clause.

Thanks! 

** NOTE-TO-JAY Questions

     Regarding ~pasteboard-cut~, I think it's rather straightforward. Please give it a go.

     As for ~kill-line~, there's something I should clarify: this is a builtin command (comes with Emacs), so it's not something I can easily change. Except that Emacs Lisp has a nice little functionality called "advicing", which allows dynamically adding behaviour to functions without having access to their code. I could do this to ~kill-line~. However, this is usually not recommended, since it could mess up other functionalities that might depend on the default ~kill-line~ implementation. Anyway, since you have the ~my/kill-line-dwim~ function, isn't that the one you use?

     Finally, regarding ~kill-clause~, I added the requested functionality, but I realised the implementation has several probably undesired behaviours. For example:

: This is a test sentence^, nothing to see here. And then another.

     Caret marks the point. In this case, calling ~kill-clause~ results in:

: This is a test sentence, ^nothing to see here. And then another.

     I.e. it only moves point. Please confirm that it should yield:

: This is a test sentence^. And then another.

     Now, going back to the current result of ~kill-clause~:

: This is a test sentence, ^nothing to see here. And then another.

     If you now invoke ~kill-clause~, you'll have:

: This is a test sentence, . ^And then another.

     This also seems silly. Again, it would seem reasonable to produce:

: This is a test sentence^. And then another.

     Finally, I found an edge case:

: This is a test sentence, nothing to see here. ^And then another.<EOB>

     Where <EOB> marks the end of the buffer. In this case, nothing happens when you invoke ~kill-clause~. I suppose it should kill the entire sentence:

: This is a test sentence, nothing to see here.^<EOB>

     Correct?

** NOTE-TO-RÚDI Answers
1. Confirming that pasteboard-cut works as requested! Since there may be times when I don't want the new behavior, I reverted pasteboard-cut itself to its original behavior and created a new function, using your new code, called pasteboard-cut-and-capitalize.
2. Similarly, yes, let's add the capitalization functionality not to kill-line, but rather to my/kill-line-dwim. 
3. Answers for kill-clause below.

This is a test sentence^, nothing to see here. And then another.

     Caret marks the point. In this case, calling ~kill-clause~ results in:

This is a test sentence, ^nothing to see here. And then another.

     I.e. it only moves point. Please confirm that it should yield:

This is a test sentence^. And then another.

: Yes! Confirmed, that is what it should yield. 

     Now, going back to the current result of ~kill-clause~:

This is a test sentence, ^nothing to see here. And then another.

     If you now invoke ~kill-clause~, you'll have:

This is a test sentence, . ^And then another.

     This also seems silly. Again, it would seem reasonable to produce:

This is a test sentence^. And then another.

: Yes, exactly! That would be the desired behavior. However, the optimal point placement for that case would be this:
This is a test sentence. ^And then another.


     Finally, I found an edge case:

This is a test sentence, nothing to see here. ^And then another.<EOB>

     Where <EOB> marks the end of the buffer. In this case, nothing happens when you invoke ~kill-clause~. I suppose it should kill the entire sentence:

This is a test sentence, nothing to see here.^<EOB>

     Correct?

: Correct! Thanks for thoroughly thinking through these cases, much appreciated! 


* DONE [#A] my/delete-backward-and-capitalize 
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-07-09 Thu 10:25
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/requests.org
  :ARCHIVE_OLPATH: open requests/Emacs
  :ARCHIVE_CATEGORY: requests
  :ARCHIVE_TODO: DONE
  :END:
See my note the end of gnu-emacs-startup.org. 

** NOTE-TO-JAY Answer

   I added a customisable variable called ~capitalize-after-deleting-single-char~. Its default value is ~nil~, so it won't capitalise if you delete a single character. However, you can enable capitalization if you set it to ~t~.

** NOTE-TO-RÚDI Perfect!
Great! Great to have that customizability. 


* DONE [#A] a simple search and replace function to add two styling tags in an email message after calling org-mime-htmlize
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-07-15 Wed 10:06
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/requests.org
  :ARCHIVE_OLPATH: open requests/Emacs
  :ARCHIVE_CATEGORY: requests
  :ARCHIVE_TODO: DONE
  :END:
When composing email in Emacs, I use org-mime, which is available through org-plus-contrib, to convert my email to HTML. After composing an email, I call a function called org-mime-htmlize, and the result is a message-mode buffer that looks something like this:

#+BEGIN_EXAMPLE
To: Jay Dixit <sunjaydixit@gmail.com>
Subject: test of org-mime
From: Jay Dixit <dixit@aya.yale.edu>
--text follows this line--
<#multipart type=alternative><#part type=text/plain>:PROPERTIES:
:SENT-ON:  Thu Jul  9 01:51:18 2015
:TO:       Jay Dixit <sunjaydixit@gmail.com>
:END:
Hello.

There's this:

- one
- two
- three

And this:
1. one
2. two
3. three

Warm regards,
Jay Dixit

---
Jay Dixit 
(646) 355-8001 
[[http://jaydixit.com/][jaydixit.com]] 
<#multipart type=related><#part type=text/html><p>
Hello.<br  />
</p>

<p>
There&rsquo;s this:<br  />
</p>

<ul class="org-ul">
<li>one<br  />
</li>
<li>two<br  />
</li>
<li>three<br  />
</li>
</ul>

<p>
And this:<br  />
</p>
<ol class="org-ol">
<li>one<br  />
</li>
<li>two<br  />
</li>
<li>three<br  />
</li>
</ol>

<p>
Warm regards,<br  />
Jay Dixit<br  />
</p>

<p>
&#x2014;<br  />
Jay Dixit<br  />
(646) 355-8001<br  />
<a href="http://jaydixit.com/">jaydixit.com</a> <br  />
</p>
<#/multipart>
<#/multipart> 
#+END_EXAMPLE

I'd like a function I can call after I call org-mime-htmlize that will add HTML styling tags at the beginning and end of the HTML part of the message. Specifically, I'd like to: 
1. add ~<div style="font-family:Georgia,serif">~ right after ~<#multipart type=related><#part type=text/html>~
2. add a closing ~</div>~ right before ~<#/multipart><#/multipart>~

So for the example above, the desired output would be: 
#+BEGIN_EXAMPLE
To: Jay Dixit <sunjaydixit@gmail.com>
Subject: test of org-mime
From: Jay Dixit <dixit@aya.yale.edu>
--text follows this line--
<#multipart type=alternative><#part type=text/plain>:PROPERTIES:
:SENT-ON:  Thu Jul  9 01:51:18 2015
:TO:       Jay Dixit <sunjaydixit@gmail.com>
:END:
Hello.

There's this:

- one
- two
- three

And this:
1. one
2. two
3. three

Warm regards,
Jay Dixit

---
Jay Dixit 
(646) 355-8001 
[[http://jaydixit.com/][jaydixit.com]] 
<#multipart type=related><#part type=text/html>
<div style="font-family:Georgia,serif"> 
<p>
Hello.<br  />
</p>

<p>
There&rsquo;s this:<br  />
</p>

<ul class="org-ul">
<li>one<br  />
</li>
<li>two<br  />
</li>
<li>three<br  />
</li>
</ul>

<p>
And this:<br  />
</p>
<ol class="org-ol">
<li>one<br  />
</li>
<li>two<br  />
</li>
<li>three<br  />
</li>
</ol>

<p>
Warm regards,<br  />
Jay Dixit<br  />
</p>

<p>
&#x2014;<br  />
Jay Dixit<br  />
(646) 355-8001<br  />
<a href="http://jaydixit.com/">jaydixit.com</a> <br  />
</p>
</div>
<#/multipart>
<#/multipart> 
#+END_EXAMPLE

Does that make sense? Thanks! 

** NOTE-TO-JAY Question

Do you want a command you can call, or do you want to *always* add the ~div~ tag? The following piece of code always adds it:

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mime-html-hook
          (lambda ()
            (goto-char (point-min))
            (insert "<div style=\"font-family:Georgia,serif\">")
            (goto-char (point-max))
            (insert "</div>")))
#+END_SRC

** NOTE-TO-RÚDI Answer
Yes, I want to always add it. This is perfect, thanks! 


* JavaScript 
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-07-18 Sat 15:32
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/requests.org
  :ARCHIVE_OLPATH: open requests
  :ARCHIVE_CATEGORY: requests
  :END:
** TODO [#B] Capture to PDF and return to Chrome
Hi Rúdi,

Do you know JavaScript? If you're interested, I might have some very quick JavaScript questions. for example the below, which comes from here:
[[http://www.devontechnologies.com/download/extras-and-manuals.html][Install browser extensions and bookmarklets, and read the help files as PDFs or ebooks - DEVONtechnologies]]

I believe it's the bookmarklet labeled "Text"

#+BEGIN_SRC javascript
javascript:window.location='x-devonthink://createText?location='+encodeURIComponent(window.location)+'&text='+encodeURIComponent(getSelection()); 
#+END_SRC

It works correctly to capture text from Chrome and insert it into a tool called DevonThink. Ideally I'd like it to automatically return me to Chrome again when it's done instead of leaving me in DevonThink. Straightforward? Thanks! 


* TESTING [#A] add "capitalize first word of next sentence" to smart-period, smart-question-mark, and smart-exclamation mark
  :PROPERTIES:
  :ARCHIVE_TIME: 2015-07-29 Wed 19:49
  :ARCHIVE_FILE: ~/Dropbox/emacs/prelude/personal/requests.org
  :ARCHIVE_OLPATH: open requests/Emacs
  :ARCHIVE_CATEGORY: requests
  :ARCHIVE_TODO: TESTING
  :END:
When I type a period, the next word after the period (i.e. the first word of the next sentence) should be automatically capitalized.

Currently, auto-capitalize-mode does this only if I type a new sentence after the period at that moment. If the next sentence is *already there*, and the first word of that sentence is uncapitalized, auto-capitalize mode does nothing. 

Therefore can you add something like the below to smart-period, smart-question-mark, and smart-exclamation mark? 

(save-excursion 
    (when (my/beginning-of-sentence-p)
      (capitalize-word 1))) 

Example:
: ^this is an existing sentence. 

Suppose the point is on the t in this and I type "Here's a new sentence. " 

Current output: 
: Here's a new sentence. ^this is an existing sentence. 

Desired output: 
: Here's a new sentence. ^This is an existing sentence. 

i.e. the period (or question mark or exclamation point) should trigger the capitalization of the first word in the next sentence. 

Thanks! 

